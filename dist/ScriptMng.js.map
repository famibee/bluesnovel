{"version":3,"file":"ScriptMng.js","sources":["../src/ts/AnalyzeTagArg.ts","../src/ts/Grammar.ts","../src/ts/ScriptIterator.ts","../src/ts/ScriptMng.ts"],"sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\n\tCopyright (c) 2018-2024 Famibee (famibee.blog38.fc2.com)\n\n\tThis software is released under the MIT License.\n\thttp://opensource.org/licenses/mit-license.php\n** ***** END LICENSE BLOCK ***** */\n\nexport interface PRM {\n\tval\t\t: string;\n\tdef?\t: string;\n};\nexport interface HPRM {\n\t[key: string]: PRM,\n};\n\nexport interface PRM_RANGE {\n\tk_ln\t: number;\n\tk_ch\t: number;\n\tv_ln\t: number;\n\tv_ch\t: number;\n\tv_len\t: number;\n};\n\nexport class AnalyzeTagArg {\n\t// 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1\n\t/*\n;[^\\n]*\n|\t(?<key>[^\\s=\"'#|;]+)\n\t(?: \\s | ;[^\\n]*\\n)*\n\t=\n\t(?: \\s | ;[^\\n]*\\n)*\n\t(?:\t(?<val> [^\\s\"'#|;]+)\n\t|\t([\"'#]) (?<val2>.*?) \\3 )\n\t(?: \\|\n\t\t(?: (?<def> [^\\s\"'#;]+)\n\t|\t([\"'#]) (?<def2>.*?) \\6 ) )?\n|\t(?<literal>[^\\s;]+)\n\t*/\n\treadonly\t#REG_TAGARG\t= /;[^\\n]*|(?<key>[^\\s=\"'#|;]+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g;\n\n\t// 【属性 = 値 | 省略値】の分析\n\tparse(args: string): void {\n\t\tthis.#hPrm = {};\n\t\tthis.#isKomeParam = false;\n\t\tfor (const {groups} of args.matchAll(this.#REG_TAGARG)) {\n\t\t\tconst {key, val, val2, def, def2, literal} = groups!;\n\t\t\tif (key) this.#hPrm[key] = {\n\t\t\t\tval: val ?? val2 ?? '',\n\t\t\t\tdef: def ?? def2\n\t\t\t};\n\t\t\telse if (literal) {\n\t\t\t\tif (literal === '*') this.#isKomeParam = true;\n\t\t\t\telse this.#hPrm[literal] = {val: '1'};\n\t\t\t}\n\t\t}\n\t}\n\n\t// 属性と値の位置をまとめて返す\n\tparseinDetail(token: string, lenNm: number, ln: number, ch: number): {[key: string]: PRM_RANGE} {\n\t\tconst hRng: {[key: string]: PRM_RANGE} = {};\n\n\t\tconst args = token.slice(1+lenNm, -1);\n\t\tfor (const {groups, index, 0: z} of args.matchAll(this.#REG_TAGARG)) {\n\t\t\tif (index === undefined) continue;\n\t\t\tconst {key, val, val2='', literal} = groups!;\n\t\t\tif (literal) {\n\t\t\t\tif (literal.endsWith('=')) {\n\t\t\t\t\tconst lenVnm = literal.length -1;\n\t\t\t\t\tconst {ch: k_ch} = this.#idx2LnCol(lenNm, ln, ch, args, index +lenVnm);\n\t\t\t\t\thRng[literal.slice(0, -1)] = {\n\t\t\t\t\t\tk_ln: ln,\n\t\t\t\t\t\tk_ch: k_ch -lenVnm,\n\t\t\t\t\t\tv_ln: ln,\n\t\t\t\t\t\tv_ch: k_ch +1,\n\t\t\t\t\t//\tv_ch: ch +1+lenNm +literal.length +1,\n\t\t\t\t\t\tv_len: 0,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (! key) continue;\n\n\t\t\tconst {ln: k_ln, ch: k_ch} = this.#idx2LnCol(lenNm, ln, ch, args, index);\n\t\t\tconst {ln: v_ln, ch: v_ch} = this.#idx2LnCol(lenNm, ln, ch, args, index +z.lastIndexOf(val ?? val2 ?? '') -(val ?0 :1));\n\t\t\thRng[key] = {k_ln, k_ch, v_ln, v_ch, v_len: val ?val.length :val2.length +2};\n\t\t}\n\n\t\treturn hRng;\n\t}\n\t\t#idx2LnCol(lenNm: number, ln: number, ch: number, args: string, idx: number): {ln: number; ch: number;} {\n\t\t\tconst sBefore = args.slice(0, idx);\n\t\t\tconst a = sBefore.split('\\n');\n\t\t\tconst len = a.length;\n\t\t\treturn {\n\t\t\t\tln\t: ln +len -1,\n\t\t\t\tch\t: len < 2 ?ch +1+lenNm +idx :a.at(-1)!.length,\n\t\t\t};\n\t\t}\n\n\t#hPrm: HPRM\t= {};\n\tget hPrm() {return this.#hPrm}\n\n\t#isKomeParam\t= false;\n\tget isKomeParam() {return this.#isKomeParam}\n\n}\n","/* ***** BEGIN LICENSE BLOCK *****\n\tCopyright (c) 2019-2024 Famibee (famibee.blog38.fc2.com)\n\n\tThis software is released under the MIT License.\n\thttp://opensource.org/licenses/mit-license.php\n** ***** END LICENSE BLOCK ***** */\n\nimport {AnalyzeTagArg} from './AnalyzeTagArg';\nimport {getFn} from './CmnLib';\nimport {type IConfig, SEARCH_PATH_ARG_EXT} from './ConfigBase';\n\n\nexport type HArg = {\n\t':タグ名'?\t: string;\n\n\tlayer?\t: string;\t// レイヤ系\n\tclass?\t: string;\n\tindex?\t: number;\n\tdive?\t: string;\n\tpage?\t: string;\n\talpha?\t: number;\n\tpivot_x?: number;\n\tpivot_y?: number;\n\trotation?\t: number;\n\tscale_x?: number;\n\tscale_y?: number;\n\tvisible?: boolean;\n\tblendmode?\t: string;\n\n\tleft?\t: number;\n\ttop?\t: number;\n\twidth?\t: number;\n\theight?\t: number;\n\tpl?\t\t: number;\n\tpr?\t\t: number;\n\tpt?\t\t: number;\n\tpb?\t\t: number;\n\n\trotate?\t: number;\n\tin_style?\t: string;\n\tout_style?\t: string;\n\tffs?\t: string;\n\tnoffs?\t: string;\n\tkinsoku_sol?\t: string;\n\tkinsoku_eol?\t: string;\n\tkinsoku_dns?\t: string;\n\tkinsoku_bura?\t: string;\n\tbura?\t: boolean;\n\tbreak_fixed?\t\t: boolean;\n\tbreak_fixed_left?\t: number;\n\tbreak_fixed_top?\t: number;\n\n\ttime?\t: number;\n\trule?\t: string;\n\tglsl?\t: string;\n\trender?\t: boolean;\n\n\tpos?\t: string;\n\ttext?\t: string;\n\twait?\t: number;\n\trecord?\t: boolean;\n\tpic?\t: string;\n\tenabled?: boolean;\n\thint?\t\t: string;\n\thint_style?\t: string;\n\thint_opt?\t: string;\n\tclickse?\t: string;\n\tenterse?\t: string;\n\tleavese?\t: string;\n\tclicksebuf?\t: string;\n\tentersebuf?\t: string;\n\tleavesebuf?\t: string;\n\tonenter?\t: string;\n\tonleave?\t: string;\n\n\tt?\t: string;\n\tr?\t: string;\n\texp?\t: string;\n\tchar?\t: string;\n\tsesame?\t: string;\n\tcast?\t: string;\n\tval?\t: string;\n\tflags?\t: string;\n\treg?\t: string;\n\tlen?\t: string;\n\turl?\t: string;\n\tformat?\t: string;\n\tchain?\t: string;\n\tpath?\t: string;\n\n\tfn?\t\t: string;\n\tface?\t: string;\n\tlabel?\t: string;\n\tcall?\t: boolean;\n\tglobal?\t: boolean;\n\tname?\t: string;\n\tclear_local_event?\t: boolean;\n\n\tstyle?\t\t\t: string;\n\tstyle_hover?\t: string;\n\tstyle_clicked?\t: string;\n\tr_style?\t\t: string;\n\tr_style_hover?\t: string;\n\tr_style_clicked?: string;\n\tr_align?\t: string;\n\n\tb_width?\t: string;\n\tb_height?\t: string;\n\tb_color?\t: string;\n\tb_alpha?\t: number;\n\tb_alpha_isfixed?\t: boolean;\n\tb_pic?\t\t: string;\n\tback_clear?\t: string;\n\n\tmax_col?\t: string;\n\tmax_row?\t: string;\n\tbura_col?\t: string;\n\tchk_overrow?\t: string;\n\n\tdx?\t: number;\n\tdy?\t: number;\n\n\tkey?\t: string;\n\ttype?\t: string;\t// 3Dレイヤで使用\n\tcamera_target?\t: string;\n\n\tbreakout?\t: Function;\n\targ?\t: HArg;\n\tfnc?\t: ()=> void;\n\n\tfilter?\t: string;\n\tmatrix?\t: string;\n\tclear_filter?\t: boolean;\n\tenable_filter?\t: boolean;\n\n\tease?\t: string;\n\tcanskip?\t:boolean;\n\n\tcentering?\t:boolean;\n\tx?\t\t: number | string;\n\ty?\t\t: number | string;\n\n\tid?\t\t\t: string;\n\tsrc?\t\t: string;\n\tvar_name?\t: string;\n\tset_fnc?\t: string;\n\tbreak_fnc?\t: string;\n\n\tswipe?\t: string;\n\tf2tap?\t: string;\n\tf2move?\t: string;\n\tf3tap?\t: string;\n\n\tfrom?\t: number;\n\tto?\t\t: number | string;\n\tplace?\t: number;\n\tadd?\t: string;\n\tdel?\t: string;\n\n\tbuf?\t: string;\t// 音系\n\tbuf2?\t: string;\n\tloop?\t: boolean;\n\tvolume?\t: number;\n\tret_ms?\t: number;\n\tend_ms?\t: number;\n\tjoin?\t: boolean;\n\tdo_rec?\t: boolean;\n\tpan?\t: number;\n\tstop?\t: boolean;\n\n\tclear?\t: boolean;\n\n\t// デザインモード\n\t':id_dc'?\t: string;\n\t':id_tag'?\t: string;\n\t':path'?\t: string;\n\t':ln'?\t\t: number;\n\t':col_s'?\t: number;\n\t':col_e'?\t: number;\n\t':idx_tkn'?\t: number;\n\t':token'?\t: string;\n\t':redraw'?\t: boolean;\n\tdesign_unit?: boolean;\t// デザインモードでこのマクロへの引数変更とするか（内部をサーチさせない）\n\n//\tstepin?\t\t: boolean;\t\t// 拡張機能のみ使用：false指定でステップインしない\n//\tnowarn_unused?\t: boolean;\t// 拡張機能のみ使用：未使用警告を出さない\n}\nexport interface ITag { (hArg: HArg): boolean; }\nexport interface IHTag { [name: string]: ITag; }\n\n\nexport type Script = {\n\taToken\t: string[];\t\t// トークン群\n\tlen\t\t: number;\t\t// トークン数\n\taLNum\t: number[];\t\t// トークンの行番号\n};\n\n\nexport const\tREG_TAG\t= /(?<name>[^\\s;\\]]+)/;\t// test用にexport\nexport function\ttagToken2Name_Args(token: string): [name: string, args: string] {\n\tconst e = REG_TAG.exec(token.slice(1, -1));\n\tconst g = e?.groups;\n\tif (! g) throw `タグ記述【${token}】異常です(タグ解析)`;\n\n\tconst nm = g.name!;\n\treturn [nm, token.slice(1 +nm.length, -1)];\n}\nexport function\ttagToken2Name(token: string): string {\n\tconst e = REG_TAG.exec(token.slice(1));\n\tconst g = e?.groups;\n\tif (! g) throw `タグ記述【${token}】異常です(タグ解析)`;\n\n\treturn g.name!;\n}\n\nexport function\tsplitAmpersand(token: string): {\n\t\tname: string;\n\t\ttext: string;\n\t\tcast: string | undefined;\n} {\t// テスト用にpublic\n\tconst equa = token.replaceAll('==', '＝').replaceAll('!=', '≠').split('=');\n\t\t// != を弾けないので中途半端ではある\n\tconst cnt_equa = equa.length;\n\tif (cnt_equa < 2 || cnt_equa > 3) throw '「&計算」書式では「=」指定が一つか二つ必要です';\n\tconst [e0, e1, e2] = equa;\n\tif (e1!.startsWith('&')) throw '「&計算」書式では「&」指定が不要です';\n\treturn {\n\t\tname: e0!.replaceAll('＝', '==').replaceAll('≠', '!='),\n\t\ttext: e1!.replaceAll('＝', '==').replaceAll('≠', '!='),\n\t\tcast: (cnt_equa === 3 ?e2!.trim() :undefined)\n\t};\n}\n\n\nexport class Grammar {\n\tconstructor(private readonly cfg: IConfig) {this.setEscape('')}\n\n\t#REG_TOKEN\t: RegExp;\n\tsetEscape(ce: string) {\n\t\tif (this.#hC2M && (ce in this.#hC2M)) throw '[エスケープ文字] char【'+ ce +'】が登録済みの括弧マクロまたは一文字マクロです';\n\n\t\t// 1083 matches (14577 step, 9.9ms) https://regex101.com/r/dP0tAY/1\n\t\t/*\n\\\\\\S |\n \\n+\n| \\t+\n|\t\\[let_ml \\s+ [^\\]]+ ]\n\t.+? (?=\\[endlet_ml [\\]\\s])\n| \\[ (?: [^\"'#;\\]]+\n\t| ([\"'#]).*?\\1\n\t| ;[^\\n]* ) *? ]\n| ;[^\\n]*\n| &[^&\\n]+&\n| &&?(?: [^\"'#;\\n&]+ | ([\"'#]).*?\\2 )+\n| ^\\*[^\\s\\[&;\\\\]+\n| [^\\n\\t\\[;\\\\]+\n\t\t*/\n/*\n\t[^\"'#;\\]]++\n\t| ([\"'\\#]).*?\\1\n\t\t\t++ にしたいところだが、jsは未サポートらしい（2022/10/16）\n*/\n\t\tthis.#REG_TOKEN = new RegExp(\n\t\t(ce\t?`\\\\${ce}\\\\S|` :'')+\t// エスケープシーケンス\n\t\t'\\\\n+'+\t\t\t\t// 改行\n\t\t'|\\\\t+'+\t\t\t// タブ文字\n\t\t`|\\\\[let_ml\\\\s+[^\\\\]]+\\\\]`+\n\t\t\t`.+?`+\t\t\t// [let_ml]〜[endlet_ml]間のテキスト\n\t\t`(?=\\\\[endlet_ml[\\\\]\\\\s])`+\n\t\t`|\\\\[(?:`+\n\t\t\t`[^\"'#;\\\\]]+|`+\t// タグ\n\t\t\t`([\"'#]).*?\\\\1` +\n\t\t\t\t// . は (?:\\\\${ ce??'\\\\' }.|[^\\\\1]) でなくてよさげ\n\t\t`|;[^\\\\n]*)*?]`+\n\t\t'|;[^\\\\n]*'+\t\t// コメント\n\t\t'|&[^&\\\\n]+&'+\t\t// ＆表示＆\n\t\t`|&&?(?:[^\"'#;\\\\n&]+|([\"'#]).*?\\\\2)+`+\t// ＆代入\n\t\t'|^\\\\*[^\\\\s\\\\[&;\\\\\\\\]+'+\t// ラベル\n\t\t`|[^\\\\n\\\\t\\\\[;${ce ?`\\\\${ce}` :''}]+`,\t\t// 本文\n\t\t'gs');\n\t\tthis.#REG_CANTC2M = new RegExp(`[\\\\w\\\\s;[\\\\]*=&｜《》${ce ?`\\\\${ce}` :''}]`);\n\t\tthis.#REG_TOKEN_NOTXT = new RegExp(`[\\\\n\\\\t;\\\\[*&${ce ?`\\\\${ce}` :''}]`);\n\t}\n\n\n\t// 括弧マクロの定義\n\tbracket2macro(hArg: HArg, hTag: IHTag, scr: Script, start_idx: number) {\n\t\tconst {name, text} = hArg;\n\t\tif (! name) throw '[bracket2macro] nameは必須です';\n\t\tif (! text) throw '[bracket2macro] textは必須です';\n\t\tconst op = text.at(0);\n\t\tif (! op) throw '[bracket2macro] textは必須です';\n\t\tif (text.length !== 2) throw '[bracket2macro] textは括弧の前後を示す二文字を指定してください';\n\t\tif (! (name in hTag)) throw `[bracket2macro] 未定義のタグ又はマクロ[${name}]です`;\n\n\t\tthis.#hC2M ??= {};\n\t\tconst cl = text.charAt(1);\n\t\tif (op in this.#hC2M) throw '[bracket2macro] text【'+ op +'】が登録済みの括弧マクロまたは一文字マクロです';\n\t\tif (cl in this.#hC2M) throw '[bracket2macro] text【'+ cl +'】が登録済みの括弧マクロまたは一文字マクロです';\n\t\tif (this.#REG_CANTC2M.test(op)) throw '[bracket2macro] text【'+ op +'】は括弧マクロに使用できない文字です';\n\t\tif (this.#REG_CANTC2M.test(cl)) throw '[bracket2macro] text【'+ cl +'】は括弧マクロに使用できない文字です';\n\n\t\tthis.#hC2M[cl] = '0';\t// チェック用ダミー\n\t\tthis.#hC2M[op] = `[${name} text=`;\n\n\t\tthis.addC2M(`\\\\${op}[^\\\\${cl}]*\\\\${cl}`, `\\\\${op}\\\\${cl}`);\n\n\t\tthis.#replaceScr_C2M(scr, start_idx);\n\t}\n\t// 一文字マクロの定義\n\tchar2macro(hArg: HArg, hTag: IHTag, scr: Script, start_idx: number) {\n\t\tconst {char, name} = hArg;\n\t\tif (! char) throw '[char2macro] charは必須です';\n\t\tthis.#hC2M ??= {};\n\t\tif (char in this.#hC2M) throw '[char2macro] char【'+ char +'】が登録済みの括弧マクロまたは一文字マクロです';\n\t\tif (this.#REG_CANTC2M.test(char)) throw '[char2macro] char【'+ char +'】は一文字マクロに使用できない文字です';\n\n\t\tif (! name) throw '[char2macro] nameは必須です';\n\t\tif (! (name in hTag)) throw `[char2macro] 未定義のタグ又はマクロ[${name}]です`;\n\n\t\tthis.#hC2M[char] = `[${name}]`;\n\n\t\tthis.addC2M(`\\\\${char}`, `\\\\${char}`);\n\n\t\tthis.#replaceScr_C2M(scr, start_idx);\n\t}\n\t#REG_CANTC2M\t: RegExp;\n\t#REGC2M\t\t\t= new RegExp('');\n\t#regStrC2M\t\t= '';\n\t#regStrC2M4not\t= '';\n\taddC2M(a: string, b: string) {\n\t\tthis.#regStrC2M += `${a}|`;\n\t\tthis.#regStrC2M4not += `${b}`;\n\t\tthis.#REGC2M = new RegExp(\n\t\t\t`(${this.#regStrC2M}[^${this.#regStrC2M4not}]+)`, 'g');\n\t}\n\n\n\tresolveScript(txt: string): Script {\n\t\tconst a = txt\n\t\t.replaceAll(/\\r\\n?/g, '\\n')\n\t\t.match(this.#REG_TOKEN)\n\t\t?.flatMap(tkn=> {\n\t\t\tif (! this.testTagLetml(tkn)) return tkn;\n\n\t\t\tconst r = /^([^\\]]+?])(.*)$/s.exec(tkn);\n\t\t\tif (! r) return tkn;\n\t\t\tconst [, a, b] = r;\n\t\t\treturn [a, b];\n\t\t}) ?? [];\n\n\t\tconst scr = {aToken: a as string[], len: a.length, aLNum: []};\n\t\tthis.#replaceScr_C2M(scr);\n\n\t\tthis.#replaceScript_Wildcard(scr);\n\n\t\treturn scr;\n\t}\n\n\n\treadonly #REG_WILDCARD\t= /^\\[(call|loadplugin)\\s/;\n\treadonly #REG_WILDCARD2\t= /\\bfn\\s*=\\s*[^\\s\\]]+/;\n\t#replaceScript_Wildcard(scr: Script) {\n\t\tfor (let i=scr.len -1; i>=0; --i) {\n\t\t\tconst token = scr.aToken[i]!;\n\t\t\tif (! this.#REG_WILDCARD.test(token)) continue;\n\n\t\t\tconst [tag_name, args] = tagToken2Name_Args(token);\n\t\t\tthis.#alzTagArg.parse(args);\n\n\t\t\tconst p_fn = this.#alzTagArg.hPrm.fn;\n\t\t\tif (! p_fn) continue;\n\t\t\tconst {val: fn} = p_fn;\n\t\t\tif (! fn || ! fn.endsWith('*')) continue;\n\n\t\t\tscr.aToken.splice(i, 1, '\\t', '; '+ token);\n\t\t\tscr.aLNum.splice(i, 1, NaN, NaN);\n\n\t\t\tconst ext = tag_name === 'loadplugin'\n\t\t\t\t? SEARCH_PATH_ARG_EXT.CSS\n\t\t\t\t: SEARCH_PATH_ARG_EXT.SN;\n\t\t\tconst a = this.cfg.matchPath('^'+ fn.slice(0, -1) +'.*', ext);\n\t\t\tfor (const v of a) {\n\t\t\t\tconst nt = token.replace(\n\t\t\t\t\tthis.#REG_WILDCARD2,\n\t\t\t\t\t'fn='+ decodeURIComponent(getFn(v[ext]!))\n\t\t\t\t);\n\t\t\t\t//console.log('\\t='+ nt +'=');\n\t\t\t\tscr.aToken.splice(i, 0, nt);\n\t\t\t\tscr.aLNum.splice(i, 0, NaN);\n\t\t\t}\n\t\t}\n\t\tscr.len = scr.aToken.length;\n\t}\n\t\treadonly\t#alzTagArg\t= new AnalyzeTagArg;\n\n\n\ttestTagLetml(tkn: string): boolean {return /^\\[let_ml\\s/.test(tkn)};\n\ttestTagEndLetml(tkn: string): boolean {return /^\\[endlet_ml\\s*]/.test(tkn)};\n\n\tanalyzToken(token: string): RegExpExecArray | null {\t// 4LspWs\n\t\tthis.#REG_TOKEN.lastIndex = 0;\t// /gなので必要\n\t\treturn this.#REG_TOKEN.exec(token);\n\t}\n\n\n\t#hC2M\t: {[char: string]: string};\n\t#REG_TOKEN_NOTXT\t: RegExp;\n\t#replaceScr_C2M(scr: Script, start_idx = 0): void {\n\t\tif (! this.#hC2M) return;\n\n\t\tfor (let i=scr.len- 1; i >= start_idx; --i) {\n\t\t\tconst token = scr.aToken[i]!;\n\t\t\tif (this.testNoTxt(token.at(0) ?? '\\n')) continue;\n\t\t\t\t// 省略時は #REG_TOKEN_NOTXT に引っかかる \\n に\n\n\t\t\tconst lnum = scr.aLNum[i]!;\n\t\t\tconst a = token.match(this.#REGC2M);\n\t\t\tif (! a) continue;\n\t\t\tlet del = 1;\n\t\t\tfor (let j=a.length -1; j>=0; --j) {\n\t\t\t\tlet ch = a[j]!;\n\t\t\t\tconst macro = this.#hC2M[ch.at(0) ?? ' '];\n\t\t\t\t\t// 省略時は #REG_CANTC2M に引っかかる ' ' に\n\t\t\t\tif (macro) {\n\t\t\t\t\tch = macro +(macro.endsWith(']')\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: (`'${ch.slice(1, -1)}']`));\n\t\t\t\t\t// 文字列は半角空白を意識して''で囲むが、いずれ変えたい場合がある？\n\t\t\t\t}\n\t\t\t\tscr.aToken.splice(i, del, ch);\n\n\t\t\t\tscr.aLNum.splice(i, del, lnum);\n\t\t\t\tdel = 0;\n\t\t\t}\n\t\t}\n\t\tscr.len = scr.aToken.length;\n\t}\n\ttestNoTxt(ch: string): boolean {return this.#REG_TOKEN_NOTXT.test(ch)};\t//4tst\n\n}\n","/* ***** BEGIN LICENSE BLOCK *****\n\tCopyright (c) 2018-2024 Famibee (famibee.blog38.fc2.com)\n\n\tThis software is released under the MIT License.\n\thttp://opensource.org/licenses/mit-license.php\n** ***** END LICENSE BLOCK ***** */\n\nimport type {SysBase} from './SysBase';\nimport {SEARCH_PATH_ARG_EXT} from './ConfigBase';\nimport {Grammar} from './Grammar';\nimport type {Script} from './Grammar';\nimport {RubySpliter} from './RubySpliter';\n\n// import {argChk_Boolean, getFn, CmnLib, argChk_Num} from './CmnLib';\n// import type {IMain, IVariable, IMark, IPropParser} from './CmnInterface';\n// import type {Config} from './Config';\n// import {CallStack, type ICallStackArg} from './CallStack';\n// import {AnalyzeTagArg} from './AnalyzeTagArg';\n// import type {EventMng} from './EventMng';\n// import type {LayerMng} from './LayerMng';\n// import {DebugMng} from './DebugMng';\n// import type {SoundMng} from './SoundMng';\n// import {disableEvent, enableEvent} from './ReadState';\n// import {CmnTween} from './CmnTween';\n\n// // import {Loader} from 'pixi.js';\n\n// interface HScript {\n// \t[fn: string]: Script;\n// };\n\n// interface ISeek {\n// \tidx\t\t: number;\n// \tln\t\t: number;\n// };\n\n\n// const enum BreakState {Running, Wait, Break, Breaking, Step, Stepping, StepOuting, StepOut};\n\n// const enum SndProcOnLoad {\n// \tMINIMAL_STOP,\n// \tNO_TOUCH,\n// \tALL_STOP_AND_PLAY,\n// };\n\n\nexport class ScriptIterator {\n\t#script\t\t: Script\t= {aToken: [''], len: 1, aLNum: [1]};\n\n\t#scriptFn\t= '';\n\t// get scriptFn() {return this.#scriptFn}\n\t#idxToken\t= 0;\n\taddIdxToken() {++this.#idxToken}\n\tsubIdxToken() {--this.#idxToken}\n\t#lineNum\t= 0;\n\tget lineNum() {return this.#lineNum}\n\treadonly addLineNum\t= (len: number)=> this.#lineNum += len;\n\t// jumpJustBefore() {this.#jumpWork(this.#scriptFn, '', --this.#idxToken)}\n\t// \t// 直前にジャンプ\n\n\n\treadonly\t#grm;\n\t// readonly\t#alzTagArg\t= new AnalyzeTagArg;\n\tasync load(fn: string): Promise<ArrayIterator<string>> {\n\t\tthis.#scriptFn = fn;\n\t\tconst path = this.sys.cfg.searchPath(fn, SEARCH_PATH_ARG_EXT.SCRIPT);\n\t\tconst txt = await this.sys.load(path);\n\t\tthis.#script = this.#grm.resolveScript(txt);\n\n\t\tthis.#idxToken = 0;\t//TODO: idx jump\n\t\tthis.#lineNum = 1;\n\n\t\treturn this.#script.aToken.slice(this.#idxToken).values();\n\t}\n\n\n\tstrPos = ()=> this.#lineNum > 0\n\t\t? `(fn:${this.#scriptFn} line:${this.#lineNum}) `\n\t\t: '';\n\n\n\t#dumpErrLine = 5;\t//TODO: \n\tdumpErrForeLine() {\n\t\tif (this.#idxToken === 0) {\n\t\t\tconsole.group(`🥟 Error line (from 0 rows before) fn:${this.#scriptFn}`);\n\t\t\tconsole.groupEnd();\n\t\t\treturn;\n\t\t}\n\n\t\tlet s = '';\n\t\tfor (let i=this.#idxToken -1; i>=0; --i) {\n\t\t\ts = this.#script.aToken[i] + s;\n\t\t\tif ((s.match(/\\n/g) ?? []).length >= this.#dumpErrLine) break;\n\t\t}\n\t\tconst a = s.split('\\n').slice(-this.#dumpErrLine);\n\t\tconst len = a.length;\n\t\tconsole.group(`🥟 Error line (from ${len} rows before) fn:${this.#scriptFn}`);\n\t\tconst ln_txt_width = String(this.#lineNum).length;\n\t\tconst lc = this.#cnvIdx2lineCol(this.#script, this.#idxToken);\n\t\tfor (let i=0; i<len; ++i) {\n\t\t\tconst ln = this.#lineNum -len +i +1;\n\t\t\tconst mes = `${String(ln).padStart(ln_txt_width, ' ')}: %c`;\n\t\t\tconst e = a[i]!;\n\t\t\tconst line = (e.length > 75) ?e.slice(0, 75) +'…' :e;\t// 長い場合は後略\n\t\t\tif (i === len -1) console.info(\n\t\t\t\tmes + line.slice(0, lc.col_s) +'%c'+ line.slice(lc.col_s),\n\t\t\t\t'color: black; background-color: skyblue;', 'color: black; background-color: pink;'\n\t\t\t)\n\t\t\telse console.info(mes + line, 'color: black; background-color: skyblue;');\n\t\t}\n\t\tconsole.groupEnd();\n\t\t//console.log('Linkの出力   : %o', 'file:///Volumes/MacHD2/_Famibee/SKYNovel/prj/mat/main.sn');\n\t}\n\t\t#cnvIdx2lineCol(st: Script, idx: number): {ln: number, col_s: number, col_e: number} {\n\t\t\tconst ret = {ln: 1, col_s: 0, col_e: 0};\n\t\t\tif (! st) return ret;\n\n\t\t\tlet i = idx -1;\n\t\t\tconst lN = ret.ln = st.aLNum[i]!;\n\t\t\twhile (st.aLNum[i] === lN) {\n\t\t\t\tif (! st.aToken[i]!.startsWith('\\n')) {\n\t\t\t\t\tconst len = st.aToken[i]!.length;\n// console.log(`fn:ScriptMng.ts line:269 cnvIdx2lineCol tkn:${st.aToken[i]} len:${len} s:${ret.col_s} e:${ret.col_e}`);\n\t\t\t\t\tif (ret.col_e > 0) ret.col_s += len;\n\t\t\t\t\tret.col_e += len;\n\t\t\t\t}\n\t\t\t\tif (--i < 0) break;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\n\n\t\n\t// #aCallStk\t: CallStack[]\t= [];\t// FILOバッファ（push/pop）\n\n\n\n\t//MARK: コンストラクタ\n\tconstructor(private readonly sys: SysBase) {\n\n\t// constructor(private readonly cfg: Config, private readonly hTag: IHTag, private readonly main: IMain, private readonly val: IVariable, private readonly prpPrs: IPropParser, private readonly sndMng: SoundMng, ) {\n// \t\t// 変数操作\n// \t\thTag.let_ml\t\t= o=> this.#let_ml(o);\t// インラインテキスト代入\n// \t\thTag.endlet_ml\t= ()=> false;\t\t\t// インラインテキスト代入終端\n// \t\t\t// [if]ブロック内で【未定義のタグ[endlet_ml]です】エラーが発生する対策\n\n// \t\t// デバッグ・その他\n// \t\thTag.dump_stack\t= ()=> this.#dump_stack();\t// スタックのダンプ\n// \t\thTag.dump_script= o=> this.#dump_script(o);\t// スクリプトのダンプ\n\n// \t\t// 条件分岐\n// \t\thTag['else']\t=\t\t\t\t\t\t\t// その他ifブロック開始\n// \t\thTag.elsif\t\t=\t\t\t\t\t\t\t// 別条件のifブロック開始\n// \t\thTag.endif\t\t= ()=> this.#endif();\t\t// ifブロックの終端\n// \t\thTag['if']\t\t= o=> this.#if(o);\t\t\t// ifブロックの開始\n\n// \t\t// ラベル・ジャンプ\n// \t\t//hTag.button\t// LayerMng.ts内で定義\t\t// ボタンを表示\n// \t\thTag.call\t\t= o=> this.#call(o);\t\t// サブルーチンコール\n// \t\thTag.jump\t\t= o=> this.#jump(o);\t\t// シナリオジャンプ\n// \t\t//hTag.page\t\t= // ReadState が担当に\t\t// ページ移動\n// \t\thTag.pop_stack\t= o=> this.#pop_stack(o);\t// コールスタック破棄\n// \t\thTag.return\t\t= o=> this.#return(o);\t\t// サブルーチンから戻る\n\n// \t\t// マクロ\n// \t\thTag.bracket2macro\t= o=> this.#bracket2macro(o);// 括弧マクロの定義\n// \t\thTag.char2macro\t\t= o=> this.#char2macro(o);\t// 一文字マクロの定義\n// \t\thTag.endmacro\t\t= o=> this.#return(o);\t\t// マクロ定義の終了\n// \t\thTag.macro\t\t\t= o=> this.#macro(o);\t\t// マクロ定義の開始\n\n// \t\t// しおり\n// \t\t//hTag.copybookmark\t\t// Variable.ts内で定義\t// しおりの複写\n// \t\t//hTag.erasebookmark\t// Variable.ts内で定義\t// しおりの消去\n// \t\thTag.load\t\t\t= o=> this.#load(o);\t\t\t// しおりの読込\n// \t\thTag.reload_script\t= o=> this.#reload_script(o);\t// スクリプト再読込\n// \t\thTag.record_place\t= ()=> this.#record_place();\t// セーブポイント指定\n// \t\thTag.save\t\t\t= o=> this.#save(o);\t\t\t// しおりの保存\n\n\n// \t\tif (cfg.oCfg.debug.token) this.#dbgToken = token=> {if (token.trim() !== '') console.log(`🌱 トークン fn:${this.#scriptFn} idx:${this.#idxToken} ln:${this.#lineNum} token【${token}】`)};\n\n// \t\tval.defTmp('const.sn.aIfStk.length', ()=> this.#aIfStk.length);\n// \t\tval.defTmp('const.sn.vctCallStk.length', ()=> this.#aCallStk.length);\n\n\t\tthis.#grm = new Grammar(sys.cfg);\n\t\t\n\t\tconst ce = sys.cfg.oCfg.init.escape;\n\t\tthis.#grm.setEscape(ce);\n\t\tRubySpliter.setEscape(ce);\n\n// \t\tif (CmnLib.isDbg) {\n// \t\t\tsys.addHook((type, o)=> this.#hHook[type]?.(o));\n// \t\t\tthis.isBreak = this.#isBreak_base;\n\n// \t\t\tconst fnc = this.analyzeInit;\n// \t\t\tthis.analyzeInit = ()=> {\n// \t\t\t\tthis.analyzeInit = ()=> {};\n// \t\t\t\tthis.sys.send2Dbg('hi', {});\n// \t\t\t};\n// \t\t\tthis.#hHook.auth = o=> {\n// \t\t\t\tconst hLineBP = o.hBreakpoint.hFn2hLineBP;\n// \t\t\t\tfor (const [fn, v] of Object.entries(hLineBP)) this.#regBreakPoint(fn, <any>v);\n\n// \t\t\t\tScriptIterator.#hFuncBP = {};\n// \t\t\t\tfor (const v of o.hBreakpoint.aFunc) {\n// \t\t\t\t\tScriptIterator.#hFuncBP[v.name] = 1;\n// \t\t\t\t}\n\n// \t\t\t\tif (o.stopOnEntry) {\n// \t\t\t\t\twhile (true) {\n// \t\t\t\t\t\tlet tkn = this.nextToken();\n// \t\t\t\t\t\tif (! tkn) break;\t// 初期化前に終了した場合向け\n\n// \t\t\t\t\t\tconst uc = tkn.charCodeAt(0);\t// TokenTopUnicode\n// \t\t\t\t\t\tif (uc === 91) break;\t// [ タグ開始\n// \t\t\t\t\t\tif (uc === 38) break;\t// & 変数操作・変数表示\n// \t\t\t\t\t\tif (uc === 42 && tkn.length === 1) break;\t// 単文字の *\n// \t\t\t\t\t\tif (uc === 10) this.#lineNum += tkn.length;\t// \\n 改行\n// \t\t\t\t\t}\n// \t\t\t\t\tthis.sys.callHook('stopOnEntry', {});\n// \t\t\t\t\tthis.analyzeInit = fnc;\n// \t\t\t\t\tthis.analyzeInit();\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tthis.noticeWait = ()=> {\n// \t\t\t\t\t\tthis.noticeWait = ()=> {};\n// \t\t\t\t\t\tthis.sys.callHook('stopOnEntry', {});\t// sn全体へ通知\n\n// //\t\t\t\t\t\tthis.sys.callHook('continue', {});\t// sn全体へ通知\n// //\t\t\t\t\t\tthis.breakState = BreakState.breaking;\n// \t\t\t\t\t};\n\n// \t\t\t\t\tthis.analyzeInit = fnc;\n// \t\t\t\t\tthis.analyzeInit();\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\telse this.recodeDesign = ()=> {};\n// \t\tif (cfg.oCfg.debug.tag) this.#procDebugtag = tag_name=> console.log(`🌲 タグ解析 fn:${this.#scriptFn} idx:${this.#idxToken} ln:${this.#lineNum} %c[${tag_name} %o]`, 'background-color:#30B;', this.#alzTagArg.hPrm);\n\t}\n// \tnoticeWait = ()=> {};\n// \t#regBreakPoint(fn: string, o: {[ln: number]: any}) {\n// \t\tScriptIterator.#hFn2hLineBP[this.#cnvSnPath4Dbg(fn)] = o;\n// \t}\n\n// \tdestroy() {this.isBreak = ()=> false}\n\n// \treadonly #hHook\t: {[type: string]: (o: any)=> void}\t= {\n// \t\t//auth: // constructorで\n// \t\t//launch:\t// ここでは冒頭停止に間に合わないのでanalyzeInit()で\n// \t\tdisconnect: ()=> {\n// \t\t\tScriptIterator.#hFn2hLineBP = {};\n// \t\t\tScriptIterator.#hFuncBP = {};\n// \t\t\tthis.isBreak = ()=> false;\n\n// \t\t\tthis.#hHook.continue!({});\n// \t\t\tthis.#breakState = BreakState.Running;\n// \t\t},\n// \t\trestart: ()=> this.isBreak = ()=> false,\n\n// \t\t// ブレークポイント登録\n// \t\tadd_break: o=> this.#regBreakPoint(o.fn, o.o),\n// \t\tdata_break: o=> {\n// \t\t\tif (this.#breakState !== BreakState.Running) return;\n\n// \t\t\tthis.#breakState = BreakState.Wait;\n// \t\t\tthis.main.setLoop(false, `変数 ${o.dataId}【${o.old_v}】→【${o.new_v}】データブレーク`);\n// \t\t\tthis.sys.callHook('stopOnDataBreakpoint', {});\t// sn全体へ通知\n// \t\t\tthis.sys.send2Dbg('stopOnDataBreakpoint', {});\n// \t\t},\n// \t\tset_func_break: o=> {\n// \t\t\tScriptIterator.#hFuncBP = {};\n// \t\t\tfor (const v of o.a) ScriptIterator.#hFuncBP[v.name] = 1;\n// \t\t\tthis.sys.send2Dbg(o.ri, {});\n// \t\t},\n\n// \t\t// 情報問い合わせ系\n// \t\tstack: o=> this.sys.send2Dbg(o.ri, {a: this.#aStack()}),\n// \t\teval: o=> {this.sys.send2Dbg(o.ri, {v: this.prpPrs.parse(o.txt)})},\n\n// \t\t// デバッガからの操作系\n// \t\tcontinue: ()=> {\n// \t\t\tif (this.#isIdxOverLast()) return;\n\n// \t\t\tthis.#idxToken -= this.#idxDx4Dbg;\n// \t\t\tthis.#breakState = BreakState.Breaking;\n// \t\t\tthis.main.setLoop(true);\n// \t\t\tthis.main.resume();\t// jumpループ後などで停止している場合があるので\n// \t\t},\n// \t\tstepover: o=> this.#go_stepover(o),\n// \t\tstepin: ()=> {\n// \t\t\tif (this.#isIdxOverLast()) return;\n\n// \t\t\tconst tkn = this.#script.aToken[this.#idxToken -this.#idxDx4Dbg];\n// \t\t\tthis.sys.callHook(`stopOnStep${this.#REGSTEPIN.test(tkn ?? '') ?'In' :''}`, {});\t// sn全体へ通知\n\n// \t\t\tthis.#idxToken -= this.#idxDx4Dbg;\n// \t\t\tthis.#breakState = this.#breakState === BreakState.Wait\n// \t\t\t\t? BreakState.Step\n// \t\t\t\t: BreakState.Stepping;\n// \t\t\tthis.main.setLoop(true);\n// \t\t\tthis.main.resume();\t// jumpループ後などで停止している場合があるので\n// \t\t},\n// \t\tstepout: o=> {\n// \t\t\tif (this.#isIdxOverLast()) return;\n\n// \t\t\tif (this.#aCallStk.length > 0) this.#go_stepout(true);\n// \t\t\telse this.#go_stepover(o);\n// \t\t},\n// \t\tpause: ()=> {\n// \t\t\tthis.#breakState = BreakState.Step;\n// \t\t\tthis.main.setLoop(false, '一時停止');\n// \t\t\tthis.sys.send2Dbg('stopOnStep', {});\n// \t\t},\n// \t\tstopOnEntry: ()=> {\n// \t\t\tthis.#breakState = BreakState.Step;\n// \t\t\tthis.main.setLoop(false, '一時停止');\n// \t\t\tthis.sys.send2Dbg('stopOnEntry', {});\n// \t\t},\n// \t};\n// \treadonly #cnvSnPath = (fn: string)=> this.cfg.searchPath(fn, SEARCH_PATH_ARG_EXT.SCRIPT);\n// \tstatic\treadonly\t#REG4CODE_FN\t= /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/;\t// https://regex101.com/r/Km54EK/1 141 steps (~0ms)\n// \treadonly #cnvSnPath4Dbg = (fn: string)=>\n// \t\t(this.sys.pathBaseCnvSnPath4Dbg + this.#cnvSnPath(fn))\n// \t\t.replace(ScriptIterator.#REG4CODE_FN, `$1/prj/$2/${this.#scriptFn}$3`);\n// \tcnvPath4Dbg = (fn: string)=> this.sys.pathBaseCnvSnPath4Dbg + fn.replace('/crypto_prj/', '/prj/');\n// \t#go_stepover(o: any) {\n// \t\tif (this.#isIdxOverLast()) return;\n\n// \t\tconst tkn = this.#script.aToken[this.#idxToken -this.#idxDx4Dbg];\n// \t\tif (this.#REGSTEPIN.test(tkn ?? '')) this.#go_stepout(false);\n// \t\telse {\n// \t\t\tthis.sys.callHook('stopOnStep', {});\t// sn全体へ通知\n// \t\t\tthis.#hHook.stepin!(o);\n// \t\t}\n// \t}\n// \t#go_stepout(out: boolean) {\n// \t\tthis.sys.callHook(`stopOnStep${out ?'Out' :''}`, {});\t// sn全体へ通知\n// \t\tthis.#csDepth_macro_esc = this.#aCallStk.length -(out ?1 :0);\n// \t\tthis.#idxToken -= this.#idxDx4Dbg;\n// \t\tthis.#breakState = out ?BreakState.StepOut :BreakState.StepOuting;\n// \t\tthis.main.setLoop(true);\n// \t\tthis.main.resume();\t// jumpループ後などで停止している場合があるので\n// \t}\n// \t#csDepth_macro_esc\t= 0;\n// \tget #idxDx4Dbg() {\n// \t\treturn this.#breakState === BreakState.Break\n// \t\t\t|| this.#breakState === BreakState.Step ?1 :0\n// \t};\n// \t#isIdxOverLast(): boolean {\n// \t\tif (this.#idxToken < this.#script.len) return false;\n// \t\tthis.sys.callHook('stopOnEntry', {});\t// sn全体へ通知\n// \t\tthis.main.setLoop(false, 'スクリプト終端です');\n// \t\treturn true;\n// \t}\n\n// \t// reload 再生成 Main に受け渡すため static\n// \tstatic\t#hFn2hLineBP: {[fn: string]: {[ln: number]: any}} = {};\n// \tstatic\t#hFuncBP: {[tag_name: string]: 1} = {};\n// \t#breakState\t= BreakState.Running;\n// \t\t// https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu\n// \tisBreak = (_token: string)=> false;\n// \t#isBreak_base(token: string): boolean {\n// \t\tswitch (this.#breakState) {\n// \t\t\tcase BreakState.StepOuting:\tthis.#subHitCondition();\n// \t\t\t\tthis.#breakState = BreakState.StepOut;\tbreak;\n// \t\t\tcase BreakState.StepOut:\n// \t\t\t\tif (this.#aCallStk.length !== this.#csDepth_macro_esc) break;\n\n// \t\t\t\tthis.#breakState = BreakState.Step;\n// \t\t\t\tthis.main.setLoop(false, 'ステップ実行');\n// \t\t\t\tthis.sys.send2Dbg('stopOnStep', {});\n// \t\t\t\treturn true;\t// タグを実行せず、直前停止\n\n// \t\t\tcase BreakState.Stepping:\tthis.#subHitCondition();\n// \t\t\t\tthis.#breakState = BreakState.Step;\tbreak;\n// \t\t\tcase BreakState.Step:\t\tthis.#subHitCondition();\n// \t\t\t\tthis.main.setLoop(false, 'ステップ実行');\n// \t\t\t\tthis.sys.send2Dbg('stopOnStep', {});\n// \t\t\t\treturn true;\t// タグを実行せず、直前停止\n\n// \t\t\tcase BreakState.Breaking:\tthis.#subHitCondition();\n// \t\t\t\tthis.#breakState = BreakState.Running;\tbreak;\n\n// \t\t\tdefault:\n// \t\t\t{\t// 関数ブレークポイント\n// \t\t\t\tif (tagToken2Name(token) in ScriptIterator.#hFuncBP) {\n// \t\t\t\t\tthis.#breakState = BreakState.Break;\n// \t\t\t\t\tthis.main.setLoop(false, `関数 ${token} ブレーク`);\n// \t\t\t\t\tthis.sys.callHook('stopOnBreakpoint', {});\t// sn全体へ通知\n// \t\t\t\t\tthis.sys.send2Dbg('stopOnBreakpoint', {});\n// \t\t\t\t\treturn true;\t// タグを実行せず、直前停止\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t{\t// ブレークポイント\n// \t\t\t\tconst bp = ScriptIterator.#hFn2hLineBP[this.#cnvSnPath4Dbg(this.#scriptFn)];\n// \t\t\t\tif (! bp) break;\n// \t\t\t\tconst o = bp[this.#lineNum];\n// \t\t\t\tif (! o) break;\n// //console.log(`fn:ScriptIterator.ts line:145 👺 【bs:${this.#breakState} idx:${this.#idxToken} ln:${this.#lineNum} tkn:${this.#script.aToken[this.#idxToken -1]}:】 o:%o`, o);\n// \t\t\t\tif (o.condition) {if (! this.prpPrs.parse(o.condition)) break}\n// \t\t\t\telse if (('hitCondition' in o) && --o.hitCondition > 0) break;\n// \t\t\t\tconst isBreak = this.#breakState === BreakState.Running;\n// \t\t\t\tthis.#breakState = BreakState.Break;\n// \t\t\t\tthis.main.setLoop(false, isBreak ?(\n// \t\t\t\t\t(o.condition ? '条件' :'ヒットカウント') +'ブレーク'\n// \t\t\t\t\t) :'ステップ実行');\n// \t\t\t\tconst type = isBreak ?'stopOnBreakpoint' :'stopOnStep';\n// \t\t\t\tthis.sys.callHook(type, {});\t// sn全体へ通知\n// \t\t\t\tthis.sys.send2Dbg(type, {});\n// \t\t\t}\n// \t\t\t\treturn true;\t// タグを実行せず、直前停止\n// \t\t}\n\n// \t\treturn false;\t// no break、タグを実行\n// \t}\n// \t#subHitCondition() {\t// step実行中でbreakしないがヒットカウントだけ減算\n// \t\tconst o = ScriptIterator.#hFn2hLineBP[getFn(this.#scriptFn)]?.[this.#lineNum];\n// \t\tif (o?.hitCondition) --o.hitCondition;\n// \t}\n\n// \t#aStack(): {fn: string, ln: number, col: number, nm: string, ma: string}[] {\n// \t\tconst idx_n = this.#breakState === BreakState.Breaking ?1 :0;\n// \t\tconst tkn0 = this.#script.aToken[this.#idxToken -1 +idx_n]!;\n\n// \t\tconst fn0 = this.#cnvSnPath4Dbg(this.#scriptFn);\n// \t\tconst tag_name0 = tagToken2Name(tkn0!);\n// \t\tconst nm = tag_name0 ?`[${tag_name0}]` :tkn0;\n// //console.log(`fn:ScriptIterator.ts aStack breakState:${this.#breakState} idx:${this.#idxToken -1} idx_n:${idx_n} tkn0:${tkn0}: fn0:${fn0} nm:${nm} tkn02:${this.#script.aToken[this.#idxToken -1]}: +tkn02:${this.#script.aToken[this.#idxToken]}:`);\n// //console.log(`fn:ScriptIterator.ts     a:%o anum:%o`, this.script.aToken, this.script.aLNum);\n// \t\tconst ma = this.val.getVal('mp:const.sn.macro') ?? '{}';\n// \t\tif (this.#idxToken === 0) return [{fn: fn0, ln: 1, col: 1, nm, ma: ma,}];\n\n// \t\tconst lc0 = this.#cnvIdx2lineCol(this.#script, this.#idxToken);// -1不要\n// //console.log(`fn:ScriptIterator.ts     ln:${lc0.ln} col:${lc0.col_s} col2:${this.#script.aLNum[this.#idxToken -1]}`);\n// \t\tconst a = [{fn: fn0, ln: lc0.ln, col: lc0.col_s +1, nm: nm, ma: ma}];\n// \t\tconst len = this.#aCallStk.length;\n// \t\tif (len === 0) return a;\n\n// \t\tfor (let i=len -1; i>=0; --i) {\n// \t\t\tconst cs = this.#aCallStk[i]!;\n// \t\t\tconst st = this.#hScript[cs.fn];\n// \t\t\tif (! st) continue;\n// \t\t\tconst tkn = st.aToken[cs.idx -1];\n// \t\t\tif (! tkn) continue;\n// \t\t\tconst lc = this.#cnvIdx2lineCol(st, cs.idx);\t// -1不要\n\n// \t\t\tconst tag_name = tagToken2Name(tkn);\n// \t\t\ta.push({\n// \t\t\t\tfn\t: this.#cnvSnPath4Dbg(cs.fn),\n// \t\t\t\tln\t: lc.ln,\n// \t\t\t\tcol\t: lc.col_s +1,\n// \t\t\t\tnm\t: tag_name ?`[${tag_name}]` :tkn,\n// \t\t\t\tma\t: cs.csArg[':hMp']['const.sn.macro'] ?? '{}',\n// \t\t\t});\n// \t\t}\n\n// \t\treturn a;\n// \t}\n\n// \t// result = true : waitする  resume()で再開\n// \t#procDebugtag\t= (_tag_name: string)=> {};\n// \t//MARK: タグ解析\n// \tタグ解析(tagToken: string): boolean {\n// \t\tconst [tag_name, args] = tagToken2Name_Args(tagToken);\n// \t\tconst tag_fnc = this.hTag[tag_name];\n// \t\tif (! tag_fnc) throw `未定義のタグ【${tag_name}】です`;\n\n// \t\tthis.#alzTagArg.parse(args);\n// \t\tthis.#procDebugtag(tag_name);\n\n// \t\tconst hPrm = this.#alzTagArg.hPrm;\n// \t\tif (hPrm.cond) {\n// \t\t\tconst cond = hPrm.cond.val;\n// \t\t\tif (! cond || cond.startsWith('&')) throw '属性condは「&」が不要です';\n// \t\t\tconst p = this.prpPrs.parse(cond);\n// \t\t\tconst ps = String(p);\n// \t\t\tif (ps === 'null' || ps === 'undefined') return false;\n// \t\t\tif (! p) return false;\n// \t\t}\n\n// \t\tlet hArg: any = {};\n// \t\tconst len = this.#aCallStk.length;\n// \t\tconst csa: any = len === 0 ?{} :this.#aCallStk[len -1]!.csArg;\n// \t\tif (this.#alzTagArg.isKomeParam) {\n// \t\t\tif (len === 0) throw '属性「*」はマクロのみ有効です';\n// \t\t\thArg = {...csa};\n// \t\t}\n// \t\thArg[':タグ名'] = tag_name;\n// \t// #region タグ位置のコールスタック情報を埋め込むコード（デバッグ用）\n// \t/*\t{\n// \t\t\tconst lc0 = this.#cnvIdx2lineCol(this.#script, this.#idxToken);\n// \t\t\tlet now = `存在位置 fn:${this.#scriptFn} line:${lc0.ln} col:${lc0.col_s +1}`;\n// \t\t\thArg[':path'] = now;\n// \t\t\tconst len = this.#aCallStk.length;\n// \t\t\tif (len > 0) {\n// \t\t\t\tfor (let i=len -1; i>=0; --i) {\n// \t\t\t\t\tconst cs = this.#aCallStk[i];\n// \t\t\t\t\tconst hMp = cs.csArg[':hMp'];\n// \t\t\t\t\tconst from_macro_nm = hMp ?hMp[':タグ名'] :undefined;\n// \t\t\t\t\tconst call_nm = cs.csArg[':タグ名'] ?? '';\n// \t\t\t\t\tconst lc = this.#cnvIdx2lineCol(this.#hScript[cs.fn], cs.idx);\n// \t\t\t\t\tnow += ` <- (${len -i}) fn:${cs.fn} line:${lc.ln\n// \t\t\t\t\t\t} col:${lc.col_s +1\n// \t\t\t\t\t\t}`+ (from_macro_nm ?'（['+ from_macro_nm +']マクロ内）' :' ')+\n// \t\t\t\t\t\t`で [${call_nm} ...]をコール`;\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}*/\n// \t// #endregion\n// \t// #region タグ位置情報を埋め込むコード（デバッグ用）\n// //\t\thArg[':path'] = this.#scriptFn;\n// //\t\thArg[':ln'] = this.#lineNum;\n// \t// #endregion\n// \t\t// valやdefの値について。null はありえない。'null'や'undefined' はありえる。\n// \t\t// 省略時以外で undefined はない。a=undefined と書いても 'undefined' になる\n// \t\tfor (const [arg_nm, {val, def}] of Object.entries(hPrm)) {\n// \t\t\tlet v = val;\n// \t\t\tif (v?.startsWith('%')) {\n// \t\t\t\tif (len === 0) throw '属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）';\n// \t\t\t\tconst mac = csa[v.slice(1)];\n// \t\t\t\tif (mac) {hArg[arg_nm] = mac; continue}\n\n// \t\t\t\tif (def === undefined || def === 'null') continue;\n// \t\t\t\t\t// defの'null'指定。%変数が無い場合、タグやマクロに属性を渡さない\n// \t\t\t\tv = def;\n// \t\t\t}\n\n// \t\t\tv = this.prpPrs.getValAmpersand(v ?? '');\n// \t\t\tif (v !== 'undefined') {hArg[arg_nm] = v; continue}\n\n// \t\t\tif (def === undefined) continue;\n// \t\t\tv = this.prpPrs.getValAmpersand(def);\n// \t\t\tif (v !== 'undefined') hArg[arg_nm] = v;\n// \t\t\t\t// 存在しない値の場合、属性を渡さない\n// \t\t}\n\n// \t\treturn tag_fnc(hArg);\n// \t}\n\n\n// \t#evtMng\t: EventMng;\n// \t#layMng\t: LayerMng;\n// \tsetOtherObj(evtMng: EventMng, layMng: LayerMng): void {\n// \t\tthis.#evtMng = evtMng;\n// \t\tthis.#layMng = layMng;\n// \t}\n\n\n// \t//MARK: インラインテキスト代入\n// \t#let_ml(hArg: HArg) {\n// \t\tconst {name} = hArg;\n// \t\tif (! name) throw 'nameは必須です';\n\n// \t\tlet ml = '';\n// \t\tconst len = this.#script.len;\n// \t\tfor (; this.#idxToken<len; ++this.#idxToken) {\n// \t\t\tml = this.#script.aToken[this.#idxToken]!;\n// \t\t\tif (ml !== '') break;\n// \t\t}\n// \t\thArg.text = ml;\n// \t\thArg.cast = 'str';\n// \t\tthis.hTag['let']!(hArg);\n// \t\tthis.#idxToken += 2;\n// \t\tthis.#lineNum += (ml.match(/\\n/g) ?? []).length;\n\n// \t\treturn false;\n// \t}\n\n\n// \t//MARK: スタックのダンプ\n// \t#dump_stack() {\n// \t\tif (this.#idxToken === 0) {\n// \t\t\tconsole.group(`🥟 [dump_stack] スクリプト現在地 fn:${this.#scriptFn} line:${1} col:${0}`);\n// \t\t\tconsole.groupEnd();\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tconst lc0 = this.#cnvIdx2lineCol(this.#script, this.#idxToken);\n// \t\tconst now = `スクリプト現在地 fn:${this.#scriptFn} line:${lc0.ln} col:${lc0.col_s +1}`;\n// \t\tconsole.group(`🥟 [dump_stack] ${now}`);\n// \t\tconst len = this.#aCallStk.length;\n// \t\tif (len > 0) {\n// \t\t\tconsole.info(now);\n// \t\t\tfor (let i=len -1; i>=0; --i) {\n// \t\t\t\tconst cs = this.#aCallStk[i]!;\n// \t\t\t\tconst hMp = cs.csArg[':hMp'];\n// \t\t\t\tconst from_macro_nm = hMp ?hMp[':タグ名'] :undefined;\n// \t\t\t\tconst call_nm = cs.csArg[':タグ名'] ?? '';\n// \t\t\t\tconst lc = this.#cnvIdx2lineCol(this.#hScript[cs.fn]!, cs.idx);\n// \t\t\t\tconsole.info(\n// \t\t\t\t\t`${len -i}つ前のコール元 fn:${cs.fn} line:${lc.ln\n// \t\t\t\t\t} col:${lc.col_s +1\n// \t\t\t\t\t}`+ (from_macro_nm ?'（['+ from_macro_nm +']マクロ内）' :' ')+\n// \t\t\t\t\t`で [${call_nm} ...]をコール`\n// \t\t\t\t);\n// \t\t\t}\n// \t\t}\n// \t\tconsole.groupEnd();\n\n// \t\treturn false;\n// \t}\n// \t#cnvIdx2lineCol(st: Script, idx: number): {ln: number, col_s: number, col_e: number} {\n// \t\tconst ret = {ln: 1, col_s: 0, col_e: 0};\n// \t\tif (! st) return ret;\n\n// \t\tlet i = idx -1;\n// \t\tconst lN = ret.ln = st.aLNum[i]!;\n// \t\twhile (st.aLNum[i] === lN) {\n// \t\t\tif (! st.aToken[i]!.startsWith('\\n')) {\n// \t\t\t\tconst len = st.aToken[i]!.length;\n// //console.log(`fn:ScriptIterator.ts line:586 cnvIdx2lineCol tkn:${st.aToken[i]} len:${len} s:${ret.col_s} e:${ret.col_e}`);\n// \t\t\t\tif (ret.col_e > 0) ret.col_s += len;\n// \t\t\t\tret.col_e += len;\n// \t\t\t}\n// \t\t\tif (--i < 0) break;\n// \t\t}\n\n// \t\treturn ret;\n// \t}\n\n\n// \t//MARK: 外部へスクリプトを表示\n// \t#dump_script(hArg: HArg) {\n// \t\tconst {set_fnc, break_fnc} = hArg;\n// \t\tif (! set_fnc) throw 'set_fncは必須です';\t// スクリプトを返すコールバック\n\n// \t\tthis.#fncSet = (globalThis as any)[set_fnc];\n// \t\tif (! this.#fncSet) {\n// \t\t\tif (argChk_Boolean(hArg, 'need_err', true)) throw `HTML内に関数${set_fnc}が見つかりません`;\n// \t\t\tthis.#fncSet = ()=> {};\n// \t\t\treturn false;\n// \t\t}\n\n// \t\tthis.noticeBreak = (goto: boolean)=> {\n// \t\t\tif (this.#fnLastBreak !== this.#scriptFn) {\n// \t\t\t\tthis.#fnLastBreak = this.#scriptFn;\n// \t\t\t\tthis.#fncSet(\n// \t\t\t\t\tthis.#hScrCache4Dump[this.#scriptFn] ??= this.#script.aToken.join('')\n// \t\t\t\t);\n// \t\t\t}\n// \t\t\tthis.#fncBreak(this.#lineNum, goto);\n// \t\t};\n// \t\tthis.noticeBreak(true);\t// 一度目のthis.fncBreak()はスルー（まだ読んでないし）\n\n// \t\tif (! break_fnc) return false;\t// Break通知コールバック\n\n// \t\tthis.#fncBreak = (globalThis as any)[break_fnc];\n// \t\tif (! this.#fncBreak) {\n// \t\t\tif (argChk_Boolean(hArg, 'need_err', true)) throw `HTML内に関数${break_fnc}が見つかりません`;\n// \t\t\tthis.#fncBreak = ()=> {};\n// \t\t}\n\n// \t\treturn false;\n// \t}\n// \t#fncSet: (txt: string)=> void = ()=> {};\n// \t#fncBreak: (ln: number, goto: boolean)=> void = ()=> {};\n// \t#fnLastBreak = '';\n// \t#hScrCache4Dump: {[fn: string]: string;} = {};\n// \tnoticeBreak = (_goto: boolean)=> {}\n\n\n// \t#dumpErrLine = 5;\n// \tdumpErrForeLine() {\n// \t\tif (this.#idxToken === 0) {\n// \t\t\tconsole.group(`🥟 Error line (from 0 rows before) fn:${this.#scriptFn}`);\n// \t\t\tconsole.groupEnd();\n// \t\t\treturn;\n// \t\t}\n\n// \t\tlet s = '';\n// \t\tfor (let i=this.#idxToken -1; i>=0; --i) {\n// \t\t\ts = this.#script.aToken[i] + s;\n// \t\t\tif ((s.match(/\\n/g) ?? []).length >= this.#dumpErrLine) break;\n// \t\t}\n// \t\tconst a = s.split('\\n').slice(-this.#dumpErrLine);\n// \t\tconst len = a.length;\n// \t\tconsole.group(`🥟 Error line (from ${len} rows before) fn:${this.#scriptFn}`);\n// \t\tconst ln_txt_width = String(this.#lineNum).length;\n// \t\tconst lc = this.#cnvIdx2lineCol(this.#script, this.#idxToken);\n// \t\tfor (let i=0; i<len; ++i) {\n// \t\t\tconst ln = this.#lineNum -len +i +1;\n// \t\t\tconst mes = `${String(ln).padStart(ln_txt_width, ' ')}: %c`;\n// \t\t\tconst e = a[i]!;\n// \t\t\tconst line = (e.length > 75) ?e.slice(0, 75) +'…' :e;\t// 長い場合は後略\n// \t\t\tif (i === len -1) console.info(\n// \t\t\t\tmes + line.slice(0, lc.col_s) +'%c'+ line.slice(lc.col_s),\n// \t\t\t\t'color: black; background-color: skyblue;', 'color: black; background-color: pink;'\n// \t\t\t)\n// \t\t\telse console.info(mes + line, 'color: black; background-color: skyblue;');\n// \t\t}\n// \t\tconsole.groupEnd();\n// \t\t//console.log('Linkの出力   : %o', 'file:///Volumes/MacHD2/_Famibee/SKYNovel/prj/mat/main.sn');\n// \t}\n\n\n// \t#aIfStk\t: number[]\t= [-1];\t// 先頭に積む FIFOバッファ（unshift / shift）\n// \t//MARK: ifブロックの終端\n// \t#endif() {\n// \t\tconst t = this.#aIfStk[0];\n// \t\tif (! t) throw `this.#aIfStk が異常です`;\n// \t\tif (t === -1) throw 'ifブロック内ではありません';\n\n// \t\tthis.#idxToken = t;\n// \t\tthis.#aIfStk.shift();\t// 最初の要素を取り除く\n\n// \t\treturn false;\n// \t}\n// \t//MARK: ifブロックの開始\n// \t#if(hArg: HArg) {\n// \t\t//console.log('if idxToken:'+ this.#idxToken);\n// \t\tconst {exp} = hArg;\n// \t\tif (! exp) throw 'expは必須です';\n// \t\tif (exp.startsWith('&')) throw '属性expは「&」が不要です';\n\n// \t\tlet cntDepth = 0;\t\t// if深度カウンター\n// \t\tlet\tidxGo = this.prpPrs.parse(exp) ?this.#idxToken :-1;\n// \t\tconst lnIf = this.#script.aLNum[this.#idxToken];\n// \t\tlet zLn = this.#lineNum -(lnIf || 0);\t// ??ではなく。NaN は falsy\n// \t\tconst len = this.#script.len;\n// \t\tfor (; this.#idxToken<len; ++this.#idxToken) {\n// \t\t\tconst ln = this.#script.aLNum[this.#idxToken];\n// \t\t\tthis.#script.aLNum[this.#idxToken] = (ln || 0)+ zLn; // ??はNaN不可\n// \t\t\tconst tkn = this.#script.aToken[this.#idxToken];\n// \t\t\t//console.log(`[if]トークン fn:${this.#scriptFn} lnum:${this.#lineNum} idx:${this.#idxToken} realLn:${this.#script.aLNum[this.#idxToken]} idxGo:${idxGo} cntDepth:${cntDepth} token<${tkn}>`);\n// \t\t\tif (! tkn) continue;\n\n// \t\t\tconst uc = tkn.charCodeAt(0);\t// TokenTopUnicode\n// \t\t\tif (uc === 10) {this.#lineNum += tkn.length; continue}\t// \\n 改行\n// \t\t\tif (uc !== 91) continue;\t// [ タグ開始以外\n\n// \t\t\tconst [tag_name, args] = tagToken2Name_Args(tkn);\n// \t\t\tif (! (tag_name in this.hTag)) throw `未定義のタグ[${tag_name}]です`;\n// \t\t\tthis.#alzTagArg.parse(args);\n\n// \t\t\tswitch (tag_name) {\n// \t\t\tcase 'if':\t++cntDepth; break;\n\n// \t\t\tcase 'elsif':\n// \t\t\t\tif (cntDepth > 0) break;\n// \t\t\t\tif (idxGo > -1) break;\n\n// \t\t\t\tconst e = this.#alzTagArg.hPrm.exp?.val;\n// \t\t\t\tif (! e) throw 'expは必須です';\n// \t\t\t\tif (e.startsWith('&')) throw '属性expは「&」が不要です';\n// \t\t\t\tif (this.prpPrs.parse(e)) idxGo = this.#idxToken +1;\n// \t\t\t\tbreak;\n\n// \t\t\tcase 'else':\n// \t\t\t\tif (cntDepth > 0) break;\n// \t\t\t\tif (idxGo === -1) idxGo = this.#idxToken +1;\n// \t\t\t\tbreak;\n\n// \t\t\tcase 'endif':\n// \t\t\t\tif (cntDepth > 0) {--cntDepth; break}\n// \t\t\t\tif (idxGo === -1) {\n// \t\t\t\t\t++this.#idxToken;\n// \t\t\t\t\tthis.#script.aLNum[this.#idxToken]! += zLn;\n// \t\t\t\t}\n// \t\t\t\telse {\n// \t\t\t\t\tthis.#aIfStk.unshift(this.#idxToken +1);\t// 先頭に要素追加\n// \t\t\t\t\tthis.#idxToken = idxGo;\n// \t\t\t\t\tthis.#lineNum = this.#script.aLNum[this.#idxToken]!;\n// \t\t\t\t\t\t// +zLn 不要\n// \t\t\t\t}\n// \t\t\t\treturn false;\n// \t\t\t}\n// \t\t}\n// \t\tthrow '[endif]がないままスクリプト終端です';\n// \t\t//return false;\n// \t}\n\n\n// \t//MARK: サブルーチンコール\n// \t#call(hArg: HArg) {\n// \t\tif (! argChk_Boolean(hArg, 'count', false)) this.#eraseKidoku();\n\n// \t\tconst {fn} = hArg;\n// \t\tif (fn) this.#cnvSnPath(fn);\t// chk only\n// \t\tthis.#callSub({...hArg, ':hEvt1Time': this.#evtMng.popLocalEvts()});\n// \t\t\t// ':hEvt1Time'の扱いだけは[macro]と異なる\n\n// \t\tif (argChk_Boolean(hArg, 'clear_local_event', false)) this.hTag.clear_event!({});\n// \t\treturn this.#jumpWork(fn, hArg.label);\n// \t}\n// \t#callSub(h: any) {\n// \t\tconst csa: ICallStackArg = {...h, ':hMp': this.val.cloneMp(), ':lenIfStk': this.#aIfStk.length};\n// \t\tthis.#script.aLNum[this.#idxToken] = this.#lineNum;\t// 戻ったときの行番号\n// \t\tif (! this.#resvToken) {csa[':resvToken'] = ''; this.#clearResvToken()}\n// \t\tthis.#aCallStk.push(new CallStack(this.#scriptFn, this.#idxToken, csa));\n// \t\tthis.#aIfStk.unshift(-1);\t// 最初に要素を追加\n// \t}\n\n// \t//MARK: シナリオジャンプ\n// \t#jump(hArg: HArg) {\n// \t\tif (! argChk_Boolean(hArg, 'count', true)) this.#eraseKidoku();\n\n// \t\tthis.#aIfStk[0] = -1;\n// \t\treturn this.#jumpWork(hArg.fn, hArg.label);\n// \t}\n\n// \t//MARK: コールスタック破棄\n// \t#pop_stack(hArg: HArg) {\n// \t\tif (argChk_Boolean(hArg, 'clear', false)) this.#aCallStk = [];\n// \t\telse if (! this.#aCallStk.pop()) throw '[pop_stack] スタックが空です';\n// \t\tthis.#clearResvToken();\n// \t\tthis.#aIfStk = [-1];\n// \t\tthis.val.setMp({});\n\n// \t\treturn false;\n// \t}\n\n// \t//MARK: サブルーチンから戻る\n// \t#return(hArg: HArg) {\n// \t\tconst cs = this.#aCallStk.pop();\n// \t\tif (! cs) throw '[return] スタックが空です';\n// \t\tconst csa = cs.csArg;\n// \t\tthis.#aIfStk = this.#aIfStk.slice(-csa[':lenIfStk']);\t// 最初の要素を取り除く\n\n// \t\tconst hMp = csa[':hMp'];\t// マクロからの復帰の場合にmp:値も復帰\n// \t\tif (hMp) this.val.setMp(hMp);\n\n// \t\tconst after_token = csa[':resvToken'];\n// \t\tif (after_token) this.nextToken = ()=> {\n// \t\t\tthis.#clearResvToken();\n// \t\t\treturn after_token;\n// \t\t}\n// \t\telse this.#clearResvToken();\n// \t\tif (csa[':hEvt1Time']) this.#evtMng.pushLocalEvts(csa[':hEvt1Time']);\n\n// \t\tconst {fn, label} = hArg;\n// \t\tif (fn || label) return this.#jumpWork(fn, label);\n\n// \t\tif (cs.fn in this.#hScript) {this.#jump_light(cs); return false}\n// \t\treturn this.#jumpWork(cs.fn, '', cs.idx);\t// 確実にスクリプトロードなので\n// \t}\n\n// \t#resvToken\t= '';\n// \t#clearResvToken() {\n// \t\tthis.#resvToken = '';\n// \t\tthis.nextToken = this.#nextToken_Proc;\n// \t}\n\n\n// \t#skipLabel = '';\n// \t#jumpWork(fn = '', label = '', idx = 0): boolean {\n// //console.log(`fn:ScriptIterator.ts %cjumpWork fn:${fn} label:${label} idx:${idx}`, 'background-color:#734e95;');\n// \t\tif (! fn && ! label) this.main.errScript('[jump系] fnまたはlabelは必須です');\n// \t\tif (label) {\n// \t\t\tif (! label.startsWith('*')) this.main.errScript('[jump系] labelは*で始まります');\n// \t\t\tthis.#skipLabel = label;\n// \t\t\tif (! this.#skipLabel.startsWith('**')) this.#idxToken = idx;\n// \t\t}\n// \t\telse {\n// \t\t\tthis.#skipLabel = '';\n// \t\t\tthis.#idxToken = idx;\n// \t\t}\n\n// \t\tif (! fn) {this.analyzeInit(); return false}\n// \t\tif (fn.includes('@')) throw `[jump系] fn には文字「@」は禁止です`;\n\n// \t\tconst full_path = this.#cnvSnPath(fn);\n// \t\tif (fn === this.#scriptFn) {this.analyzeInit(); return false}\n// \t\tthis.#scriptFn = fn;\n// \t\tconst st = this.#hScript[fn];\n// \t\tif (st) {this.#script = st; this.analyzeInit(); return false}\n\n// \t\tdisableEvent();\n// \t\tconst ldr = new Loader;\n// \t\tlet fp_diff = '';\n// \t\ttry {\n// \t\t\tfp_diff = this.#cnvSnPath(fn +'@');\n// \t\t\t// 派生ファイルが存在する場合\n// \t\t\tldr.add({name: fn +':base', url: full_path});\n// \t\t\tldr.add({name: fn, url: fp_diff});\n// \t\t} catch {\n// \t\t\t// 派生ファイルはない\n// \t\t\tldr.add({name: fn, url: full_path});\n// \t\t}\n// \t\tldr.use(async (res, next)=> {\n// \t\t\ttry {\n// \t\t\t\tres.data = await this.sys.dec(res.extension, res.data);\n// \t\t\t} catch (e) {\n// \t\t\t\tthis.main.errScript(`[jump系]snロード失敗です fn:${res.name} ${e}`, false);\n// \t\t\t}\n// \t\t\tnext();\n// \t\t})\n// \t\t.load((_ldr, hRes)=> {\n// \t\t\tif (fp_diff) {\t// 派生ファイルが存在する場合\n// \t\t\t\tconst scrBase = hRes[fn +':base']!.data;\n// \t\t\t\tconst scrDiff = hRes[fn]!.data;\n// \t\t\t\tconst aBase = scrBase.split('\\n');\n// \t\t\t\tconst aDiff = scrDiff.split('\\n');\n// \t\t\t\tconst lenB = aBase.length;\n// \t\t\t\tconst lenD = aDiff.length;\n// \t\t\t\t// 【派生スクリプト】の空行へ、【基底スクリプト】の同じ行の内容をコピー\n// \t\t\t\tfor (let i=0; i<lenD && i<lenB; ++i) aDiff[i] ||= aBase[i];\n\n// \t\t\t\t// 【接尾辞つきファイル】として扱う\n// \t\t\t\thRes[fn]!.data = aDiff.join('\\n');\n// \t\t\t\tdelete hRes[fn +':base'];\n// \t\t\t}\n\n// \t\t\tthis.nextToken = this.#nextToken_Proc;\n// \t\t\tthis.#lineNum = 1;\n\n// \t\t\tthis.#resolveScript(hRes[fn]!.data);\n// \t\t\tthis.hTag.record_place!({});\n// \t\t\tthis.analyzeInit();\n// \t\t\tenableEvent();\n// \t\t});\n\n// \t\treturn true;\n// \t}\n// \tprivate\tanalyzeInit(): void {\n// //console.log(`%cfn:ScriptIterator.ts line:841 analyzeInit()`, 'color:#3B0;');\n// \t\tconst o = this.#seekScript(this.#script, Boolean(this.val.getVal('mp:const.sn.macro.name')), this.#lineNum, this.#skipLabel, this.#idxToken);\n// \t\tthis.#idxToken\t= o.idx;\n// \t\tthis.#lineNum\t= o.ln;\n// \t}\n\n// \t// シナリオ解析処理ループ・冒頭処理\n// \tnextToken = ()=> '';\t// 初期化前に終了した場合向け\n// \t#nextToken_Proc(): string {\n// \t\tif (this.#errOverScr()) return '';\n\n// \t\tthis.#recordKidoku();\n\n// \t\t// トークンの行番号更新\n// \t\tthis.#script.aLNum[this.#idxToken] ||= this.#lineNum;\t// ??はNaN不可\n// \t\tconst token = this.#script.aToken[this.#idxToken]!;\n// \t\tthis.#dbgToken(token);\n// \t\t++this.#idxToken;\n\n// \t\treturn token;\n// \t}\n// \t#dbgToken = (_token: string)=> {};\n// \t#errOverScr(): boolean {\n// \t\tif (this.#idxToken < this.#script.len) return false;\n// \t\tthis.main.errScript('スクリプト終端です');\n// \t\treturn true;\n// \t}\n\n\n// \treadonly #REG_NONAME_LABEL\t\t= /(\\*{2,})([^\\|]*)/;\n// \treadonly #REG_TOKEN_MACRO_BEGIN\t= /^\\[macro\\s/;\n// \treadonly #REG_TOKEN_MACRO_END\t= /^\\[endmacro[\\s\\]]/;\n// \t#seekScript(st: Script, inMacro: boolean, ln: number, skipLabel: string, idx: number): ISeek {\n// \t\t//console.log(`seekScript (from)inMacro:${inMacro} (from)ln:${ln} (to)skipLabel:${skipLabel}: (to)idx:${idx}`);\n// \t\tconst len = st.aToken.length;\n// \t\tif (! skipLabel) {\t// ラベルジャンプ以外（先頭から開始）\n// \t\t\tif (this.#errOverScr()) return {idx, ln};\n\n// \t\t\tif (! st.aLNum[idx]) {\t// NaN、undefined は falsy\n// \t\t\t\tln = 1;\n// \t\t\t\tfor (let j=0; j<idx; ++j) {\n// \t\t\t\t\t// 走査ついでにトークンの行番号も更新\n// \t\t\t\t\tst.aLNum[j] ||= ln;\t// ??はNaN不可\n\n// \t\t\t\t\tconst tkn = st.aToken[j]!;\n// \t\t\t\t\tif (tkn.startsWith('\\n')) ln += tkn.length;\t// \\n 改行\n// \t\t\t\t\telse ln += (tkn.match(/\\n/g) ?? []).length;\n// \t\t\t\t}\n// \t\t\t\tst.aLNum[idx] = ln;\n// \t\t\t}\n// \t\t\telse ln = st.aLNum[idx];\n\n// \t\t\treturn {idx, ln};\n// \t\t}\n\n// \t\t// 無名ラベルジャンプ\n// \t\tst.aLNum[0] = 1;\n// \t\tconst a_skipLabel = skipLabel.match(this.#REG_NONAME_LABEL);\n// \t\tif (a_skipLabel) {\n// \t\t\tskipLabel = a_skipLabel[1]!;\n// \t\t\tlet i = idx;\n// \t\t\tswitch (a_skipLabel[2]) {\n// \t\t\tcase 'before':\n// \t\t\t\twhile (st.aToken[--i] !== skipLabel) {\n// \t\t\t\t\tif (i === 0) DebugMng.myTrace('[jump系 無名ラベルbefore] '\n// \t\t\t\t\t\t+ ln +'行目以前で'+ (inMacro ?'マクロ内に' :'')\n// \t\t\t\t\t\t+ 'ラベル【'+ skipLabel +'】がありません', 'ET');\n// \t\t\t\t\tif (inMacro && st.aToken[i]!.search(this.#REG_TOKEN_MACRO_BEGIN) > -1) DebugMng.myTrace('[jump系 無名ラベルbefore] マクロ内にラベル【'+ skipLabel +'】がありません', 'ET');\n// \t\t\t\t}\n// \t\t\t\treturn {idx: i +1, ln: st.aLNum[i]!};\t//\tbreak;\n\n// \t\t\tcase 'after':\n// \t\t\t\twhile (st.aToken[++i] !== skipLabel) {\n// \t\t\t\t\tif (i === len) DebugMng.myTrace('[jump系 無名ラベルafter] '\n// \t\t\t\t\t\t+ ln +'行目以後でマクロ内にラベル【'+ skipLabel +'】がありません', 'ET');\n// \t\t\t\t\tif (st.aToken[i]!.search(this.#REG_TOKEN_MACRO_END) > -1) DebugMng.myTrace('[jump系 無名ラベルafter] '\n// \t\t\t\t\t\t+ ln +'行目以後でマクロ内にラベル【'+ skipLabel +'】がありません', 'ET');\n// \t\t\t\t}\n// \t\t\t\treturn {idx: i +1, ln: st.aLNum[i]!};\t//\tbreak;\n\n// \t\t\tdefault:\n// \t\t\t\tDebugMng.myTrace('[jump系] 無名ラベル指定【label='+ skipLabel +'】が間違っています', 'ET');\n// \t\t\t}\n// \t\t}\n\n// \t\t// ラベルジャンプ\n// \t\tln = 1;\n// \t\tconst reLabel = new RegExp(\n// \t\t\t'^'+ skipLabel.replaceAll('*', '\\\\*') +'(?=\\\\s|;|\\\\[|\\\\||$)');\n// \t\tlet in_let_ml = false;\n// \t\tfor (let i=0; i<len; ++i) {\n// \t\t\t// 走査ついでにトークンの行番号も更新\n// \t\t\tst.aLNum[i] ||= ln;\t// ??はNaN不可\n\n// \t\t\tconst tkn = st.aToken[i]!;\n// \t\t\tif (in_let_ml) {\n// \t\t\t\tif (this.#grm.testTagEndLetml(tkn)) in_let_ml = false;\n// \t\t\t\telse ln += (tkn.match(/\\n/g) ?? []).length;\n// \t\t\t\tcontinue;\n// \t\t\t}\n\n// \t\t\tconst uc = tkn.charCodeAt(0);\t// TokenTopUnicode\n// \t\t\tif (uc === 10) {ln += tkn.length; continue}\t// \\n 改行\n// \t\t\tif (uc === 42) {\t// 42 = *\n// \t\t\t\tif (tkn.search(reLabel) > -1) return {idx: i +1, ln};//\tbreak;\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t\tif (uc !== 91) continue;\t// [ タグ開始\n\n// \t\t\tln += (tkn.match(/\\n/g) ?? []).length;\n// \t\t\tif (this.#grm.testTagLetml(tkn)) in_let_ml = true;\n// \t\t}\n// \t\tif (in_let_ml) throw '[let_ml]の終端・[endlet_ml]がありません';\n\n// \t\tDebugMng.myTrace(`[jump系] ラベル【${skipLabel}】がありません`, 'ET');\n// \t\tthrow 'Dummy';\n// \t}\n\n// \t#hScript\t: HScript\t= Object.create(null);\t//{} シナリオキャッシュ\n// \t#resolveScript(txt: string) {\n// \t\tlet mes = '';\n// \t\ttry {\n// \t\t\tmes = 'ScriptIterator.resolveScript';\n// \t\t\tconst scr = this.#grm.resolveScript(txt);\n// \t\t\tmes = 'ScriptIterator.replaceScript_Wildcard';\n// \t\t\tthis.#replaceScript_Wildcard(scr);\n// \t\t\tthis.#hScript[this.#scriptFn] = this.#script = scr;\n// \t\t}\n// \t\tcatch (e) {\n// \t\t\tif (e instanceof Error) mes += `例外 mes=${e.message}(${e.name})`;\n// \t\t\telse mes = String(e);\n// \t\t\tthis.main.errScript(mes, false);\n// \t\t}\n// \t\tthis.val.touchAreaKidoku(this.#scriptFn);\n// \t}\n\n// \t#jump_light(cs: CallStack) {\n// \t\t// jumpでは連続マクロでスタックオーバーフローになるので簡易版を\n// \t\t// 主に[return]やマクロ終了でジャンプ先がチェック不要な場合用\n// \t\t// analyzeInit()とかもジャンプ前にやってて不要だし\n// \t\tthis.#scriptFn\t= cs.fn;\n// \t\tthis.#idxToken\t= cs.idx;\n// \t\tconst st = this.#hScript[this.#scriptFn];\n// \t\tif (st) this.#script = st;\n// \t\tthis.#lineNum = this.#script.aLNum[cs.idx]!;\n// //console.log(`fn:ScriptIterator.ts %cjump_light cs.fn:${cs.fn} cs.idx:${cs.idx} ln:${this.#lineNum}`, 'background-color:#a03b79;');\n// \t}\n\n\n// \treadonly #REG_WILDCARD\t= /^\\[(call|loadplugin)\\s/;\n// \treadonly #REG_WILDCARD2\t= /\\bfn\\s*=\\s*[^\\s\\]]+/;\n// \t#replaceScript_Wildcard(scr: Script) {\n// \t\tfor (let i=scr.len -1; i>=0; --i) {\n// \t\t\tconst token = scr.aToken[i]!;\n// \t\t\tif (! this.#REG_WILDCARD.test(token)) continue;\n\n// \t\t\tconst [tag_name, args] = tagToken2Name_Args(token);\n// \t\t\tthis.#alzTagArg.parse(args);\n\n// \t\t\tconst p_fn = this.#alzTagArg.hPrm.fn;\n// \t\t\tif (! p_fn) continue;\n// \t\t\tconst {val: fn} = p_fn;\n// \t\t\tif (! fn || ! fn.endsWith('*')) continue;\n\n// \t\t\tscr.aToken.splice(i, 1, '\\t', '; '+ token);\n// \t\t\tscr.aLNum.splice(i, 1, NaN, NaN);\n\n// \t\t\tconst ext = tag_name === 'loadplugin'\n// \t\t\t\t? SEARCH_PATH_ARG_EXT.CSS\n// \t\t\t\t: SEARCH_PATH_ARG_EXT.SN;\n// \t\t\tconst a = this.cfg.matchPath('^'+ fn.slice(0, -1) +'.*', ext);\n// \t\t\tfor (const v of a) {\n// \t\t\t\tconst nt = token.replace(\n// \t\t\t\t\tthis.#REG_WILDCARD2,\n// \t\t\t\t\t'fn='+ decodeURIComponent(getFn(v[ext]!))\n// \t\t\t\t);\n// \t\t\t\t//console.log('\\t='+ nt +'=');\n// \t\t\t\tscr.aToken.splice(i, 0, nt);\n// \t\t\t\tscr.aLNum.splice(i, 0, NaN);\n// \t\t\t}\n// \t\t}\n// \t\tscr.len = scr.aToken.length;\n// \t}\n\n\n// \t#recordKidoku() {\n// \t\tconst areas = this.val.touchAreaKidoku(this.#scriptFn);\n\n// \t\t// マクロ内やサブルーチンではisKidokuを変更させない\n// \t\tif (this.#aCallStk.length > 0) {areas.record(this.#idxToken); return}\n\n// \t\tthis.#isKidoku = areas.search(this.#idxToken);\n// \t\tthis.val.setVal_Nochk('tmp', 'const.sn.isKidoku', this.#isKidoku);\n// \t\tif (this.#isKidoku) return;\n\n// \t\tareas.record(this.#idxToken);\n// \t\t// saveKidoku()\n// \t\t\t// 厳密にはここですべきだが、パフォーマンスに問題があるので\n// \t\t\t// クリック待ちを期待できるwait、waitclick、s、l、pタグで\n// \t\t\t// saveKidoku()をコール。\n// \t}\n// \t#isKidoku\t= false;\n// \tget isKidoku() {return this.#isKidoku};\n// \t#eraseKidoku() {\n// \t\tthis.val.getAreaKidoku(this.#scriptFn)?.erase(this.#idxToken);\n// \t\tthis.#isKidoku = false;\n// \t}\n// \tget isNextKidoku(): boolean {\n// \t\tlet fn\t= this.#scriptFn;\n// \t\tlet idx\t= this.#idxToken;\n// \t\tlet len\t= this.#script.len;\n// \t\tif (this.#aCallStk.length > 0) {\n// \t\t\tconst cs = this.#aCallStk[0]!;\n// \t\t\tfn  = cs.fn;\n// \t\t\tidx = cs.idx;\n// \t\t\tconst st = this.#hScript[fn];\n// \t\t\tif (st) len = st.len;\n// \t\t}\n\n// \t\tconst areas = this.val.getAreaKidoku(fn);\n// \t\tif (idx === len) return false;\t// スクリプト終端\n\n// \t\t//traceDbg(\"isNextKidoku fn:\"+ fn +\" idx:\"+ idx +\" ret=\"+ (areas.search(idx)));\n// \t\t//traceDbg(\"【\"+ vctT[idx-1] +\"】【\"+ vctT[idx] +\"】\");\n\n// \t\treturn areas.search(idx);\n// \t}\n\n\n// \tget normalWait(): number {\n// \t\treturn this.#isKidoku\n// \t\t? (\n// \t\t\tthis.val.tagCh_doWait_Kidoku\n// \t\t\t?\tthis.val.tagCh_msecWait_Kidoku\n// \t\t\t:\t0\n// \t\t)\n// \t\t: (\n// \t\t\tthis.val.tagCh_doWait\n// \t\t\t?\tthis.val.tagCh_msecWait\n// \t\t\t:\t0\n// \t\t);\n// \t}\n\n\n// \t//MARK: 括弧マクロの定義\n// \t#bracket2macro(hArg: HArg) {\n// \t\tthis.#grm.bracket2macro(hArg, this.hTag, this.#script, this.#idxToken);\n\n// \t\treturn false;\n// \t}\n\n// \t//MARK: 一文字マクロの定義\n// \t#char2macro(hArg: HArg) {\n// \t\tthis.#grm.char2macro(hArg, this.hTag, this.#script, this.#idxToken);\n\n// \t\treturn false;\n// \t}\n\n// \t//MARK: マクロ定義の開始\n// \treadonly\t#REG_NG4MAC_NM = /[\"'#;\\\\]　]+/;\n// \t#macro(hArg: HArg) {\n// \t\tconst {name} = hArg;\n// \t\tif (! name) throw 'nameは必須です';\n// \t\tif (name in this.hTag) throw `[${name}]はタグかすでに定義済みのマクロです`;\n// \t\tif (this.#REG_NG4MAC_NM.test(name)) throw `[${name}]はマクロ名として異常です`;\n\n// \t\tconst ln = this.#lineNum;\n// \t\tconst cs = new CallStack(this.#scriptFn, this.#idxToken);\n// \t\tthis.#strStepin += '|'+ name;\n// \t\tthis.#REGSTEPIN = new RegExp(`\\\\[(${this.#strStepin})\\\\b`);\n// \t\tthis.hTag[name] = hArgM=> {\n// \t\t\thArgM.design_unit = hArg.design_unit;\n// \t\t\tthis.#callSub(hArgM);\n\n// \t\t\t// AIRNovelの仕様：親マクロが子マクロコール時、*がないのに値を引き継ぐ\n// \t\t\t//for (const k of Object.keys(hArg)) this.val.setVal_Nochk('mp', k, hArg[k]);\n// \t\t\tthis.val.setMp(hArgM as any);\n// \t\t\tthis.val.setVal_Nochk('mp', 'const.sn.macro', JSON.stringify({\n// \t\t\t\tname: hArg.name,\n// \t\t\t}));\t// ムダに大きいスクリプター用情報を削除\n// \t\t\tthis.val.setVal_Nochk('mp', 'const.sn.me_call_scriptFn', this.#scriptFn);\n\n// \t\t\tthis.#lineNum = ln;\n// \t\t\tthis.#jump_light(cs);\n\n// \t\t\treturn false;\n// \t\t};\n\n// \t\tfor (; this.#idxToken < this.#script.len; ++this.#idxToken) {\n// \t\t\t// トークンの行番号更新\n// \t\t\tthis.#script.aLNum[this.#idxToken] ||= this.#lineNum; // ??はNaN不可\n\n// \t\t\tconst token = this.#script.aToken[this.#idxToken]!;\n// \t\t\tif (token.search(this.#REG_TOKEN_MACRO_END) > -1) {\n// \t\t\t\t++this.#idxToken;\n// \t\t\t\treturn false;\n// \t\t\t}\n\n// \t\t\tconst uc = token.charCodeAt(0);\t// TokenTopUnicode\n// \t\t\tif (uc === 10) this.#lineNum += token.length;\t// \\n 改行\n// \t\t\telse if (uc === 91) this.#lineNum += (token.match(/\\n/g) ?? []).length;\t// [ タグ開始\n// \t\t}\n// \t\tthrow `マクロ[${name}]定義の終端・[endmacro]がありません`;\n// \t}\n// \t#strStepin\t= 'call';\n// \t#REGSTEPIN\t= /\\[(call)\\b/;\t// https://regex101.com/r/Lk9ASK/1\n\n\n// \t//MARK: しおりの読込\n// \t#load(hArg: HArg) {\n// \t\tif (('fn' in hArg) !== ('label' in hArg)) throw 'fnとlabelはセットで指定して下さい';\n\n// \t\tconst place = argChk_Num(hArg, 'place', 0);\n// \t\tconst mark = this.val.getMark(place);\n\n// \t\treturn this.loadFromMark(hArg, mark, SndProcOnLoad.ALL_STOP_AND_PLAY);\n// \t}\n// \tloadFromMark(hArg: HArg, mark: IMark, snd: SndProcOnLoad = SndProcOnLoad.MINIMAL_STOP) {\n// \t\tthis.hTag.clear_event!({});\n// \t\tthis.val.mark2save(mark);\n// \t\tthis.val.setMp({});\n// \t\tthis.#layMng.recPagebreak();\n\n// \t\tlet ap: Promise<void>[] = [];\n// \t\tif (snd !== SndProcOnLoad.NO_TOUCH) ap = this.sndMng\n// \t\t.playLoopFromSaveObj(snd === SndProcOnLoad.ALL_STOP_AND_PLAY);\n\n// \t\tif (argChk_Boolean(hArg, 'do_rec', true)) this.#mark = {\n// \t\t\thSave\t: this.val.cloneSave(),\n// \t\t\thPages\t: {...mark.hPages},\n// \t\t\taIfStk\t: [...mark.aIfStk],\n// \t\t}\n\n// \t\tconst o: HArg = {\n// \t\t\tenabled\t: this.val.getVal('save:const.sn.autowc.enabled'),\n// \t\t\ttext\t: this.val.getVal('save:const.sn.autowc.text'),\n// \t\t\ttime\t: Number(this.val.getVal('save:const.sn.autowc.time')),\n// \t\t};\n// \t\tthis.hTag.autowc!(o);\n\n// \t\tthis.#aIfStk = [...this.#mark.aIfStk];\n// \t\tthis.#aCallStk = [];\n// \t\tCmnTween.stopAllTw();\n\n// \t\tconst p = Promise.allSettled([...ap, ...this.#layMng.playback(this.#mark.hPages)])\n// \t\t.then(()=> this.#layMng.cover(false))\n// \t\t.catch(e=> console.error(`fn:ScriptIterator.ts loadFromMark e:%o`, e));\n// \t\tconst {index, fn} = hArg;\n// \t\tif (index) {\t// ページ移動用\n// //console.log(`fn:ScriptIterator.ts \\x1b[42mmove!\\x1b[49m fn:${fn} idx:${index}`);\n// \t\t\tp.then(()=> this.#jumpWork(fn, '', index));\n// \t\t\treturn true;\n// \t\t}\n\n// \t\tthis.#layMng.cover(true);\t// ページ移動では全画面黒で覆わない\n// \t\tdisableEvent();\n// \t\tconst fn2 = String(this.val.getVal('save:const.sn.scriptFn'));\n// \t\tconst idx = Number(this.val.getVal('save:const.sn.scriptIdx'));\n// \t\tdelete this.#hScript[fn2];\t// 必ずスクリプトを再読込。吉里吉里に動作を合わせる\n// \t\tconst {label} = hArg;\n// \t\tif (label) p.then(()=> {\n// \t\t\tthis.#scriptFn = fn2;\n// \t\t\tthis.#idxToken = idx;\n// \t\t\tthis.hTag.call!({fn, label});\n// \t\t});\n// \t\telse p.then(()=> this.#jumpWork(fn2, '', idx));\n\n// \t\treturn true;\n// \t}\n\n// \t//MARK: スクリプト再読込\n// \t#reload_script(hArg: HArg) {\t// 最後の[record_place]から再開\n// \t\tconst mark = this.val.getMark(0);\n// \t\t// 起動から再読込までの間に追加・変更・削除されたファイルがあるかも、に対応\n// \t\t//\tdelete this.hScript[this.#scriptFn];\t// これだと[reload_script]位置になる\n// \t\tdelete this.#hScript[getFn(mark.hSave['const.sn.scriptFn'])];\n\n// \t\t// 派生ファイルを削除\n// \t\tconst h: HScript = {};\n// \t\tfor (const fn in this.#hScript) {\n// \t\t\ttry {this.#cnvSnPath(fn +'@')}\n// \t\t\tcatch {h[fn] = this.#hScript[fn]!}\t// 派生ファイル以外を残す\n// \t\t}\n// \t\tthis.#hScript = h;\n\n// \t\thArg.do_rec = false;\n// \t\treturn this.loadFromMark(hArg, mark, SndProcOnLoad.NO_TOUCH);\n// \t}\n\n\n// \t//MARK: セーブポイント指定\n// \t#mark: IMark = {\n// \t\thSave\t: {},\n// \t\thPages\t: {},\n// \t\taIfStk\t: [-1],\n// \t};\n// \t#record_place() {\n// \t\tif (this.main.isDestroyed()) return false;\n\n// \t\tconst {fn, idx} = this.nowScrIdx();\n// \t\tthis.val.setVal_Nochk('save', 'const.sn.scriptFn', fn);\n// \t\tthis.val.setVal_Nochk('save', 'const.sn.scriptIdx', idx);\n// \t\tthis.#mark = {\n// \t\t\thSave\t: this.val.cloneSave(),\n// \t\t\thPages\t: this.#layMng.record(),\n// \t\t\taIfStk\t: this.#aIfStk.slice(this.#aCallStk.length),\n// \t\t};\n\n// \t\treturn false;\n// \t}\n// \tnowScrIdx(): {fn: string, idx: number} {\n// \t\tconst len = this.#aCallStk.length;\n// \t\tif (len === 0) return {\n// \t\t\tfn\t: this.#scriptFn,\n// \t\t\tidx\t: this.#idxToken,\n// \t\t};\n\n// \t\tconst cs = this.#aCallStk[0]!;\n// \t\treturn {\n// \t\t\tfn\t: cs.fn,\n// \t\t\tidx\t: cs.idx,\n// \t\t}\n// \t}\n// \tnowMark(): IMark {return {...this.#mark}}\n\n// \t//MARK: スクリプト停止位置（マクロなどなら最上位の呼び元）\n// \tnowScrFnLn(): {fn: string, ln: number, col_s: number, col_e: number} {\n// \t\tconst {fn, idx} = this.nowScrIdx();\n// \t\tconst st = this.#hScript[fn]!;\n// \t\tconst o = this.#cnvIdx2lineCol(st, idx);\t// -1不要\n// \t\treturn {fn, ...o};\n// \t}\n\n// \t//MARK: しおりの保存\n// \t#save(hArg: HArg) {\n// \t\tif (! ('place' in hArg)) throw 'placeは必須です';\n// \t\tconst place = Number(hArg.place);\n\n// \t\tdelete hArg[':タグ名'];\n// \t\tdelete hArg.place;\n// \t\thArg.text = hArg.text ?? '';\n// \t\tthis.#mark.json = hArg;\n// \t\tthis.val.setMark(place, this.#mark);\n\n// \t\tconst now_sp = Number(this.val.getVal('sys:const.sn.save.place'));\n// \t\tif (place === now_sp) this.val.setVal_Nochk('sys', 'const.sn.save.place', now_sp +1);\n\n// \t\treturn false;\n// \t}\n\n\n// \trecodeDesign(hArg: HArg) {\n// \t\tlet fn = '';\n// \t\tlet idx = 0;\n\n// \t\tconst len = this.#aCallStk.length;\n// \t\tif (hArg.design_unit && len > 0) {\n// \t\t\t// デザインモードでこのマクロへの引数変更とするか（内部をサーチさせない）\n// \t\t\tconst cs = this.#aCallStk[0]!;\n// \t\t\tfn = cs.fn;\n// \t\t\tidx = cs.idx;\n// \t\t}\n// \t\telse {\n// \t\t\tfn = this.#scriptFn;\n// \t\t\tidx = this.#idxToken;\n// \t\t}\n// \t\thArg[':path']\t= this.#cnvSnPath4Dbg(fn);\n// \t\tconst scr = this.#hScript[fn]!;\n// \t\tconst lc = this.#cnvIdx2lineCol(scr, idx);\n// \t\thArg[':ln']\t\t= lc.ln;\n// \t\thArg[':col_s']\t= lc.col_s;\n// \t\thArg[':col_e']\t= lc.col_e;\n// \t\tconst idx_1 = idx -1;\n// \t\thArg[':idx_tkn']= idx_1;\n// \t\thArg[':token']\t= scr.aToken[idx_1];\n\n// \t\tthis.sys.send2Dbg('_recodeDesign', hArg);\n// \t}\n// \treplace(idx: number, val: string) {this.#script.aToken[idx] = val}\n\n}\n","/* ***** BEGIN LICENSE BLOCK *****\n\tCopyright (c) 2024-2024 Famibee (famibee.blog38.fc2.com)\n\n\tThis software is released under the MIT License.\n\thttp://opensource.org/licenses/mit-license.php\n** ***** END LICENSE BLOCK ***** */\n\nimport type {SysBase} from './SysBase';\nimport {type HArg, type IHTag, tagToken2Name} from './Grammar';\nimport type {T_LAY} from '../components/Stage';\nimport type {T_CHGPIC, T_CHGSTR, T_INIT_FNCS} from '../store/store';\nimport {CmnLib} from './CmnLib';\nimport {ScriptIterator} from './ScriptIterator';\n\ntype T_TRACE = (txt: string, lvl?: 'D'|'W'|'F'|'E'|'I'|'ET')=> void;\n\n\nexport class ScriptMng {\n\treadonly\t#spnDbg\t: HTMLSpanElement;\n\treadonly\t#scrItr\t: ScriptIterator;\n\n\tconstructor(private readonly sys: SysBase) {\n\t\tthis.#spnDbg = document.createElement('span');\n\t\tthis.#spnDbg.hidden = true;\n\t\tthis.#spnDbg.textContent = '';\n\t\tthis.#spnDbg.style.cssText =\n\t\t`\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`\n\t\tdocument.body.appendChild(this.#spnDbg);\n\n\t\tthis.#scrItr = new ScriptIterator(sys);\n\n\t\tthis.#hTag.trace\t\t= o=> this.#trace(o);\t\t\t// デバッグ表示へ出力\n\t}\n\n\t// Main.tsx からの初期化\n\tattachTsx(trgNext: ()=> void, fncs: T_INIT_FNCS, hTag: IHTag) {\n\t\tthis.$trgNext = trgNext;\n\t\tthis.$fncs = fncs;\n\t\tthis.#hTag = hTag;\n\n\t\tthis.#hTag.title = ({text})=> {\n\t\t\tif (! text) throw '[title] textは必須です';\n\n\t\t\t// this.#main_title = text;\t//TODO: \n\t\t\t// this.titleSub(this.#main_title + this.#info_title);\n\t\t\tfncs.addTitle(text);\n\n\t\t\treturn false;\n\t\t};\n\t}\n\t\t$trgNext\t: ()=> void;\n\t\t$fncs\t\t: T_INIT_FNCS;\n\t\t#hTag\t\t: IHTag\t\t= Object.create(null);\t// タグ処理辞書\n\n\n\tasync load(fn: string) {\n\t\t//NOTE: 同じidxの更新をチェックか\n\n\t\t//TODO: スクリプト解析ループ・開始\n\t\t//TODO: [l][p][s][wait]での状態を保存\n\n\t\tconst gen = await this.#scrItr.load(fn);\n\t\twhile (true) {\n\t\t\tconst {done, value} = gen.next();\n\t\t\tif (done) {this.myTrace('🎍 スクリプト末尾', 'E'); break}\n\t\t\tthis.#scrItr.addIdxToken();\n\n\t\t\tlet token = value;\n// console.log(`fn:ScriptMng.ts 🍉 %o`, token);\n\t\t\tswitch (value.charAt(0)) {\n\t\t\t\tcase '\\t':\tcontinue;\t//  タブ\n\n\t\t\t\tcase '\\n':\t// 改行\n\t\t\t\t\tthis.#scrItr.addLineNum(token.length);\tcontinue;\n\n\t\t\t\tcase '[':\t// タグ開始\nconsole.log(`fn:ScriptMng.ts 🍊 TAG ${token}`);\n\t\t\t\t\tif (this.#isBreak(token)) return;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst cl = (token.match(/\\n/g) ?? []).length;\n\t\t\t\t\t\tif (cl > 0) this.#scrItr.addLineNum(cl);\n\t\t\t\t\t\t// if (this.#scrItr.タグ解析(token)) {this.stop(); return}\t//TODO: \n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tif (e instanceof Error) this.myTrace(`[${tagToken2Name(token)}]タグ解析中例外 mes=${e.message}(${e.name})`);\n\t\t\t\t\t\telse this.myTrace(String(e));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase '&':\t//  変数操作・変数表示\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (! value.endsWith('&')) {\t//変数操作\n\t\t\t\t\t\t\t//TODO: 変数計算\n\t\t\t\t\t\t\tif (this.#isBreak(token)) return;\n\t\t\t\t\t\t\t// const o = splitAmpersand(token.slice(1));\n\t\t\t\t\t\t\t// o.name = this.#getValAmpersand(o.name);\n\t\t\t\t\t\t\t// o.text = String(this.#parse(o.text));\n\t\t\t\t\t\t\t// this.#hTag.let!(o);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (value.charAt(1) === '&') throw new Error('「&表示&」書式では「&」指定が不要です');\n\t\t\t\t\t\t// token = String(this.#parse( token.slice(1, -1) ));\t//TODO: \n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\tthis.myTrace(\n\t\t\t\t\t\t\terr instanceof Error\n\t\t\t\t\t\t\t\t? `& 変数操作・表示 mes=${err.message}(${err.name})`\n\t\t\t\t\t\t\t\t: String(err)\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ';':\tcontinue;\t// コメント\n\n\t\t\t\tcase '*':\t\t//  ラベル\n\t\t\t\t\tif (value.length > 1) continue;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//TODO: 文字表示\n\t\t\ttry {\n\t\t\t\t// this.#layMng.setNormalChWait();\t//TODO: \n\t\t\t\t// const tl = this.#layMng.currentTxtlayForeNeedErr;\n\t\t\t\t// tl.tagCh(token);\nconsole.log(`fn:ScriptMng.ts 🍈 tagCh:${token}`);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis.myTrace(\n\t\t\t\t\terr instanceof Error\n\t\t\t\t\t\t? `文字表示 mes=${err.message}(${err.name})`\n\t\t\t\t\t\t: String(err)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\n\t\tfunction* gene1(): Generator<T_LAY | T_CHGPIC | T_CHGSTR> {\n\t\t\tyield {cls: 'GRP', nm: 'base', fn: 'yun_1184'};\n\t\t\tyield {cls: 'TXT', nm: 'mes', str: 'あいうえお'};\n\t\t\tyield {nm: 'mes', str: 'かきくけこ'};\n\t\t\tyield {cls: 'GRP', nm: 'fg0', fn: 'F_1024a'};\n\t\t\tyield {nm: 'base', fn: 'yun_1317'};\n\t\t}\n\t\tconst gen1 = gene1();\n\t\tlet idxDummy = 0;\n\t\tthis.go = ()=> {\nconsole.log(`fn:ScriptMng.ts == go ==`);\n\t\t\twhile (true) {\n\t\t\t\tconst {done, value: o} = gen1.next();\n\t\t\t\tif (done) break;\n\t\n\t\t\t\tthis.sys.caretaker.push(fn +':'+ ++idxDummy);\n\t\t\t\tif ('cls' in o) this.$fncs.addLayer(o); else\n\t\t\t\tif ('fn' in o) this.$fncs.chgPic(o); else this.$fncs.chgStr(o);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tthis.$trgNext();\n\t}\n\t\t#isBreak = (_token: string)=> false;\t//TODO: \n\n\tgo() {}\n\n\n\t#trace(hArg: HArg) {\n\t\tthis.myTrace(hArg.text || `(text is ${hArg.text})`, 'I');\n\n\t\treturn false;\n\t}\n\treadonly\tmyTrace: T_TRACE = (txt, lvl = 'E')=> {\n\t\tlet sty = '';\n\t\tswitch (lvl) {\n\t\t\tcase 'D':\tsty = 'color:#05A;';\tbreak;\n\t\t\tcase 'W':\tsty = 'color:#F80;';\tbreak;\n\t\t\tcase 'F':\tsty = 'color:#B00;';\tbreak;\n\t\t\tcase 'ET':\n\t\t\tcase 'E':\tsty = 'color:#F30;';\tbreak;\n\t\t\tdefault:\tsty = '';\n\t\t}\n\n\t\tconst mes = `{${lvl}} `+ this.#scrItr.strPos() + txt;\n\t\tthis.#spnDbg.innerHTML += `<span style='${sty}'>${mes}</span><br/>`;\n\t\tthis.#spnDbg.hidden = false;\n\n\t\tswitch (lvl) {\n\t\t\tcase 'D':\tif (CmnLib.isDarkMode) sty = `color:#49F;`;\tbreak;\n\t\t\tcase 'W':\n\t\t\tcase 'F':\tbreak;\n\t\t\tcase 'ET':\n\t\t\tcase 'E':\n\t\t\t\tthis.#hTag.title!({text: txt});\n\t\t\t\t/*if (CmnLib.osName === \"AND\") {\n\t\t\t\t\tconst buf = \"mailto:foo@hoge.co.jp\"\n\t\t\t\t\t\t+ \"?subject=AIRNovel_ERR&body=\"\n\t\t\t\t\t\t+ CmnLib.escapeZenkaku(mes) + \"\\n\"\n\t\t\t\t\t\t+ \"※一部記号は全角表示しています。\";\n\t\t\t\t\tflash.net.navigateToURL(new URLRequest(buf));\n\t\t\t\t}*/\n\t\t\t\t// this.#hTag.dump_lay!({});\t//TODO: \n\t\t\t\t// this.#hTag.dump_val!({});\t//TODO: \n\t\t\t\tthis.#scrItr.dumpErrForeLine();\n\t\t\t\t// this.#hTag.dump_stack!({});\t//TODO: \n\n\t\t\t\tif (lvl === 'ET') throw mes;\n\t\t\t\tbreak;\n\t\t\tdefault:\tsty = '';\n\t\t}\n\t\tconsole.info('%c '+ mes, sty);\n\t}\n\n}\n"],"names":["AnalyzeTagArg","#REG_TAGARG","args","#hPrm","#isKomeParam","groups","key","val","val2","def","def2","literal","token","lenNm","ln","ch","hRng","index","z","lenVnm","k_ch","#idx2LnCol","k_ln","v_ln","v_ch","idx","a","len","REG_TAG","tagToken2Name_Args","g","nm","tagToken2Name","Grammar","cfg","#REG_TOKEN","ce","#hC2M","#REG_CANTC2M","#REG_TOKEN_NOTXT","hArg","hTag","scr","start_idx","name","text","op","cl","#replaceScr_C2M","char","#REGC2M","#regStrC2M","#regStrC2M4not","b","txt","tkn","r","#replaceScript_Wildcard","#REG_WILDCARD","#REG_WILDCARD2","i","tag_name","#alzTagArg","p_fn","fn","ext","SEARCH_PATH_ARG_EXT","v","nt","getFn","lnum","del","j","macro","ScriptIterator","sys","#grm","#script","#scriptFn","#idxToken","#lineNum","path","#dumpErrLine","s","ln_txt_width","lc","#cnvIdx2lineCol","mes","e","line","st","ret","lN","ScriptMng","#spnDbg","#scrItr","#hTag","o","#trace","trgNext","fncs","gen","done","value","#isBreak","err","gene1","gen1","idxDummy","_token","lvl","sty"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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"}